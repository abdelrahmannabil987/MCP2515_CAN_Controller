
MCP2515_Receiver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e5a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000010  00800060  00800060  00000ece  2**0
                  ALLOC
  2 .stab         00001668  00000000  00000000  00000ed0  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000c46  00000000  00000000  00002538  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 db 06 	jmp	0xdb6	; 0xdb6 <__vector_13>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a0 37       	cpi	r26, 0x70	; 112
  6c:	b1 07       	cpc	r27, r17
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <main>
  74:	0c 94 2b 07 	jmp	0xe56	; 0xe56 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <DIO_VidInit>:
#include "STD_TYPE.h"
#include "BIT_MATH.h"
#include "DIO_private.h"

void DIO_VidInit(void)
{
  7c:	df 93       	push	r29
  7e:	cf 93       	push	r28
  80:	cd b7       	in	r28, 0x3d	; 61
  82:	de b7       	in	r29, 0x3e	; 62

}
  84:	cf 91       	pop	r28
  86:	df 91       	pop	r29
  88:	08 95       	ret

0000008a <DIO_VidSetPortDirection>:

void DIO_VidSetPortDirection(u8 Copy_U8Port, u8 Copy_U8Direction)
{
  8a:	df 93       	push	r29
  8c:	cf 93       	push	r28
  8e:	00 d0       	rcall	.+0      	; 0x90 <DIO_VidSetPortDirection+0x6>
  90:	00 d0       	rcall	.+0      	; 0x92 <DIO_VidSetPortDirection+0x8>
  92:	cd b7       	in	r28, 0x3d	; 61
  94:	de b7       	in	r29, 0x3e	; 62
  96:	89 83       	std	Y+1, r24	; 0x01
  98:	6a 83       	std	Y+2, r22	; 0x02
    switch(Copy_U8Port)
  9a:	89 81       	ldd	r24, Y+1	; 0x01
  9c:	28 2f       	mov	r18, r24
  9e:	30 e0       	ldi	r19, 0x00	; 0
  a0:	3c 83       	std	Y+4, r19	; 0x04
  a2:	2b 83       	std	Y+3, r18	; 0x03
  a4:	8b 81       	ldd	r24, Y+3	; 0x03
  a6:	9c 81       	ldd	r25, Y+4	; 0x04
  a8:	81 30       	cpi	r24, 0x01	; 1
  aa:	91 05       	cpc	r25, r1
  ac:	d1 f0       	breq	.+52     	; 0xe2 <DIO_VidSetPortDirection+0x58>
  ae:	2b 81       	ldd	r18, Y+3	; 0x03
  b0:	3c 81       	ldd	r19, Y+4	; 0x04
  b2:	22 30       	cpi	r18, 0x02	; 2
  b4:	31 05       	cpc	r19, r1
  b6:	2c f4       	brge	.+10     	; 0xc2 <DIO_VidSetPortDirection+0x38>
  b8:	8b 81       	ldd	r24, Y+3	; 0x03
  ba:	9c 81       	ldd	r25, Y+4	; 0x04
  bc:	00 97       	sbiw	r24, 0x00	; 0
  be:	61 f0       	breq	.+24     	; 0xd8 <DIO_VidSetPortDirection+0x4e>
  c0:	1e c0       	rjmp	.+60     	; 0xfe <DIO_VidSetPortDirection+0x74>
  c2:	2b 81       	ldd	r18, Y+3	; 0x03
  c4:	3c 81       	ldd	r19, Y+4	; 0x04
  c6:	22 30       	cpi	r18, 0x02	; 2
  c8:	31 05       	cpc	r19, r1
  ca:	81 f0       	breq	.+32     	; 0xec <DIO_VidSetPortDirection+0x62>
  cc:	8b 81       	ldd	r24, Y+3	; 0x03
  ce:	9c 81       	ldd	r25, Y+4	; 0x04
  d0:	83 30       	cpi	r24, 0x03	; 3
  d2:	91 05       	cpc	r25, r1
  d4:	81 f0       	breq	.+32     	; 0xf6 <DIO_VidSetPortDirection+0x6c>
  d6:	13 c0       	rjmp	.+38     	; 0xfe <DIO_VidSetPortDirection+0x74>
    {
        case 0 :    DDRA = Copy_U8Direction; break;
  d8:	ea e3       	ldi	r30, 0x3A	; 58
  da:	f0 e0       	ldi	r31, 0x00	; 0
  dc:	8a 81       	ldd	r24, Y+2	; 0x02
  de:	80 83       	st	Z, r24
  e0:	0e c0       	rjmp	.+28     	; 0xfe <DIO_VidSetPortDirection+0x74>
        case 1 :    DDRB = Copy_U8Direction; break;
  e2:	e7 e3       	ldi	r30, 0x37	; 55
  e4:	f0 e0       	ldi	r31, 0x00	; 0
  e6:	8a 81       	ldd	r24, Y+2	; 0x02
  e8:	80 83       	st	Z, r24
  ea:	09 c0       	rjmp	.+18     	; 0xfe <DIO_VidSetPortDirection+0x74>
        case 2 :    DDRC = Copy_U8Direction; break;
  ec:	e4 e3       	ldi	r30, 0x34	; 52
  ee:	f0 e0       	ldi	r31, 0x00	; 0
  f0:	8a 81       	ldd	r24, Y+2	; 0x02
  f2:	80 83       	st	Z, r24
  f4:	04 c0       	rjmp	.+8      	; 0xfe <DIO_VidSetPortDirection+0x74>
        case 3 :    DDRD = Copy_U8Direction; break;
  f6:	e1 e3       	ldi	r30, 0x31	; 49
  f8:	f0 e0       	ldi	r31, 0x00	; 0
  fa:	8a 81       	ldd	r24, Y+2	; 0x02
  fc:	80 83       	st	Z, r24
    }
}
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
 102:	0f 90       	pop	r0
 104:	0f 90       	pop	r0
 106:	cf 91       	pop	r28
 108:	df 91       	pop	r29
 10a:	08 95       	ret

0000010c <DIO_VidSetPinDirection>:

void DIO_VidSetPinDirection(u8 Copy_U8Port, u8 Copy_U8Pin, u8 Copy_U8Direction)
{
 10c:	df 93       	push	r29
 10e:	cf 93       	push	r28
 110:	cd b7       	in	r28, 0x3d	; 61
 112:	de b7       	in	r29, 0x3e	; 62
 114:	27 97       	sbiw	r28, 0x07	; 7
 116:	0f b6       	in	r0, 0x3f	; 63
 118:	f8 94       	cli
 11a:	de bf       	out	0x3e, r29	; 62
 11c:	0f be       	out	0x3f, r0	; 63
 11e:	cd bf       	out	0x3d, r28	; 61
 120:	89 83       	std	Y+1, r24	; 0x01
 122:	6a 83       	std	Y+2, r22	; 0x02
 124:	4b 83       	std	Y+3, r20	; 0x03
    if(Copy_U8Direction == 1)
 126:	8b 81       	ldd	r24, Y+3	; 0x03
 128:	81 30       	cpi	r24, 0x01	; 1
 12a:	09 f0       	breq	.+2      	; 0x12e <DIO_VidSetPinDirection+0x22>
 12c:	6f c0       	rjmp	.+222    	; 0x20c <DIO_VidSetPinDirection+0x100>
    {
        switch (Copy_U8Port)
 12e:	89 81       	ldd	r24, Y+1	; 0x01
 130:	28 2f       	mov	r18, r24
 132:	30 e0       	ldi	r19, 0x00	; 0
 134:	3f 83       	std	Y+7, r19	; 0x07
 136:	2e 83       	std	Y+6, r18	; 0x06
 138:	8e 81       	ldd	r24, Y+6	; 0x06
 13a:	9f 81       	ldd	r25, Y+7	; 0x07
 13c:	81 30       	cpi	r24, 0x01	; 1
 13e:	91 05       	cpc	r25, r1
 140:	49 f1       	breq	.+82     	; 0x194 <DIO_VidSetPinDirection+0x88>
 142:	2e 81       	ldd	r18, Y+6	; 0x06
 144:	3f 81       	ldd	r19, Y+7	; 0x07
 146:	22 30       	cpi	r18, 0x02	; 2
 148:	31 05       	cpc	r19, r1
 14a:	2c f4       	brge	.+10     	; 0x156 <DIO_VidSetPinDirection+0x4a>
 14c:	8e 81       	ldd	r24, Y+6	; 0x06
 14e:	9f 81       	ldd	r25, Y+7	; 0x07
 150:	00 97       	sbiw	r24, 0x00	; 0
 152:	61 f0       	breq	.+24     	; 0x16c <DIO_VidSetPinDirection+0x60>
 154:	d2 c0       	rjmp	.+420    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
 156:	2e 81       	ldd	r18, Y+6	; 0x06
 158:	3f 81       	ldd	r19, Y+7	; 0x07
 15a:	22 30       	cpi	r18, 0x02	; 2
 15c:	31 05       	cpc	r19, r1
 15e:	71 f1       	breq	.+92     	; 0x1bc <DIO_VidSetPinDirection+0xb0>
 160:	8e 81       	ldd	r24, Y+6	; 0x06
 162:	9f 81       	ldd	r25, Y+7	; 0x07
 164:	83 30       	cpi	r24, 0x03	; 3
 166:	91 05       	cpc	r25, r1
 168:	e9 f1       	breq	.+122    	; 0x1e4 <DIO_VidSetPinDirection+0xd8>
 16a:	c7 c0       	rjmp	.+398    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
        {
            case 0 : SET_BIT(DDRA,Copy_U8Pin); break;
 16c:	aa e3       	ldi	r26, 0x3A	; 58
 16e:	b0 e0       	ldi	r27, 0x00	; 0
 170:	ea e3       	ldi	r30, 0x3A	; 58
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	80 81       	ld	r24, Z
 176:	48 2f       	mov	r20, r24
 178:	8a 81       	ldd	r24, Y+2	; 0x02
 17a:	28 2f       	mov	r18, r24
 17c:	30 e0       	ldi	r19, 0x00	; 0
 17e:	81 e0       	ldi	r24, 0x01	; 1
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	02 2e       	mov	r0, r18
 184:	02 c0       	rjmp	.+4      	; 0x18a <DIO_VidSetPinDirection+0x7e>
 186:	88 0f       	add	r24, r24
 188:	99 1f       	adc	r25, r25
 18a:	0a 94       	dec	r0
 18c:	e2 f7       	brpl	.-8      	; 0x186 <DIO_VidSetPinDirection+0x7a>
 18e:	84 2b       	or	r24, r20
 190:	8c 93       	st	X, r24
 192:	b3 c0       	rjmp	.+358    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
            case 1 : SET_BIT(DDRB,Copy_U8Pin); break;
 194:	a7 e3       	ldi	r26, 0x37	; 55
 196:	b0 e0       	ldi	r27, 0x00	; 0
 198:	e7 e3       	ldi	r30, 0x37	; 55
 19a:	f0 e0       	ldi	r31, 0x00	; 0
 19c:	80 81       	ld	r24, Z
 19e:	48 2f       	mov	r20, r24
 1a0:	8a 81       	ldd	r24, Y+2	; 0x02
 1a2:	28 2f       	mov	r18, r24
 1a4:	30 e0       	ldi	r19, 0x00	; 0
 1a6:	81 e0       	ldi	r24, 0x01	; 1
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	02 2e       	mov	r0, r18
 1ac:	02 c0       	rjmp	.+4      	; 0x1b2 <DIO_VidSetPinDirection+0xa6>
 1ae:	88 0f       	add	r24, r24
 1b0:	99 1f       	adc	r25, r25
 1b2:	0a 94       	dec	r0
 1b4:	e2 f7       	brpl	.-8      	; 0x1ae <DIO_VidSetPinDirection+0xa2>
 1b6:	84 2b       	or	r24, r20
 1b8:	8c 93       	st	X, r24
 1ba:	9f c0       	rjmp	.+318    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
            case 2 : SET_BIT(DDRC,Copy_U8Pin); break;
 1bc:	a4 e3       	ldi	r26, 0x34	; 52
 1be:	b0 e0       	ldi	r27, 0x00	; 0
 1c0:	e4 e3       	ldi	r30, 0x34	; 52
 1c2:	f0 e0       	ldi	r31, 0x00	; 0
 1c4:	80 81       	ld	r24, Z
 1c6:	48 2f       	mov	r20, r24
 1c8:	8a 81       	ldd	r24, Y+2	; 0x02
 1ca:	28 2f       	mov	r18, r24
 1cc:	30 e0       	ldi	r19, 0x00	; 0
 1ce:	81 e0       	ldi	r24, 0x01	; 1
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	02 2e       	mov	r0, r18
 1d4:	02 c0       	rjmp	.+4      	; 0x1da <DIO_VidSetPinDirection+0xce>
 1d6:	88 0f       	add	r24, r24
 1d8:	99 1f       	adc	r25, r25
 1da:	0a 94       	dec	r0
 1dc:	e2 f7       	brpl	.-8      	; 0x1d6 <DIO_VidSetPinDirection+0xca>
 1de:	84 2b       	or	r24, r20
 1e0:	8c 93       	st	X, r24
 1e2:	8b c0       	rjmp	.+278    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
            case 3 : SET_BIT(DDRD,Copy_U8Pin); break;
 1e4:	a1 e3       	ldi	r26, 0x31	; 49
 1e6:	b0 e0       	ldi	r27, 0x00	; 0
 1e8:	e1 e3       	ldi	r30, 0x31	; 49
 1ea:	f0 e0       	ldi	r31, 0x00	; 0
 1ec:	80 81       	ld	r24, Z
 1ee:	48 2f       	mov	r20, r24
 1f0:	8a 81       	ldd	r24, Y+2	; 0x02
 1f2:	28 2f       	mov	r18, r24
 1f4:	30 e0       	ldi	r19, 0x00	; 0
 1f6:	81 e0       	ldi	r24, 0x01	; 1
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	02 2e       	mov	r0, r18
 1fc:	02 c0       	rjmp	.+4      	; 0x202 <DIO_VidSetPinDirection+0xf6>
 1fe:	88 0f       	add	r24, r24
 200:	99 1f       	adc	r25, r25
 202:	0a 94       	dec	r0
 204:	e2 f7       	brpl	.-8      	; 0x1fe <DIO_VidSetPinDirection+0xf2>
 206:	84 2b       	or	r24, r20
 208:	8c 93       	st	X, r24
 20a:	77 c0       	rjmp	.+238    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
        }
    }
    else if (Copy_U8Direction == 0)
 20c:	8b 81       	ldd	r24, Y+3	; 0x03
 20e:	88 23       	and	r24, r24
 210:	09 f0       	breq	.+2      	; 0x214 <DIO_VidSetPinDirection+0x108>
 212:	73 c0       	rjmp	.+230    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
    {
        switch (Copy_U8Port)
 214:	89 81       	ldd	r24, Y+1	; 0x01
 216:	28 2f       	mov	r18, r24
 218:	30 e0       	ldi	r19, 0x00	; 0
 21a:	3d 83       	std	Y+5, r19	; 0x05
 21c:	2c 83       	std	Y+4, r18	; 0x04
 21e:	8c 81       	ldd	r24, Y+4	; 0x04
 220:	9d 81       	ldd	r25, Y+5	; 0x05
 222:	81 30       	cpi	r24, 0x01	; 1
 224:	91 05       	cpc	r25, r1
 226:	59 f1       	breq	.+86     	; 0x27e <DIO_VidSetPinDirection+0x172>
 228:	2c 81       	ldd	r18, Y+4	; 0x04
 22a:	3d 81       	ldd	r19, Y+5	; 0x05
 22c:	22 30       	cpi	r18, 0x02	; 2
 22e:	31 05       	cpc	r19, r1
 230:	2c f4       	brge	.+10     	; 0x23c <DIO_VidSetPinDirection+0x130>
 232:	8c 81       	ldd	r24, Y+4	; 0x04
 234:	9d 81       	ldd	r25, Y+5	; 0x05
 236:	00 97       	sbiw	r24, 0x00	; 0
 238:	69 f0       	breq	.+26     	; 0x254 <DIO_VidSetPinDirection+0x148>
 23a:	5f c0       	rjmp	.+190    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
 23c:	2c 81       	ldd	r18, Y+4	; 0x04
 23e:	3d 81       	ldd	r19, Y+5	; 0x05
 240:	22 30       	cpi	r18, 0x02	; 2
 242:	31 05       	cpc	r19, r1
 244:	89 f1       	breq	.+98     	; 0x2a8 <DIO_VidSetPinDirection+0x19c>
 246:	8c 81       	ldd	r24, Y+4	; 0x04
 248:	9d 81       	ldd	r25, Y+5	; 0x05
 24a:	83 30       	cpi	r24, 0x03	; 3
 24c:	91 05       	cpc	r25, r1
 24e:	09 f4       	brne	.+2      	; 0x252 <DIO_VidSetPinDirection+0x146>
 250:	40 c0       	rjmp	.+128    	; 0x2d2 <DIO_VidSetPinDirection+0x1c6>
 252:	53 c0       	rjmp	.+166    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
        {
            case 0 : CLR_BIT(DDRA,Copy_U8Pin); break;
 254:	aa e3       	ldi	r26, 0x3A	; 58
 256:	b0 e0       	ldi	r27, 0x00	; 0
 258:	ea e3       	ldi	r30, 0x3A	; 58
 25a:	f0 e0       	ldi	r31, 0x00	; 0
 25c:	80 81       	ld	r24, Z
 25e:	48 2f       	mov	r20, r24
 260:	8a 81       	ldd	r24, Y+2	; 0x02
 262:	28 2f       	mov	r18, r24
 264:	30 e0       	ldi	r19, 0x00	; 0
 266:	81 e0       	ldi	r24, 0x01	; 1
 268:	90 e0       	ldi	r25, 0x00	; 0
 26a:	02 2e       	mov	r0, r18
 26c:	02 c0       	rjmp	.+4      	; 0x272 <DIO_VidSetPinDirection+0x166>
 26e:	88 0f       	add	r24, r24
 270:	99 1f       	adc	r25, r25
 272:	0a 94       	dec	r0
 274:	e2 f7       	brpl	.-8      	; 0x26e <DIO_VidSetPinDirection+0x162>
 276:	80 95       	com	r24
 278:	84 23       	and	r24, r20
 27a:	8c 93       	st	X, r24
 27c:	3e c0       	rjmp	.+124    	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
            case 1 : CLR_BIT(DDRB,Copy_U8Pin); break;
 27e:	a7 e3       	ldi	r26, 0x37	; 55
 280:	b0 e0       	ldi	r27, 0x00	; 0
 282:	e7 e3       	ldi	r30, 0x37	; 55
 284:	f0 e0       	ldi	r31, 0x00	; 0
 286:	80 81       	ld	r24, Z
 288:	48 2f       	mov	r20, r24
 28a:	8a 81       	ldd	r24, Y+2	; 0x02
 28c:	28 2f       	mov	r18, r24
 28e:	30 e0       	ldi	r19, 0x00	; 0
 290:	81 e0       	ldi	r24, 0x01	; 1
 292:	90 e0       	ldi	r25, 0x00	; 0
 294:	02 2e       	mov	r0, r18
 296:	02 c0       	rjmp	.+4      	; 0x29c <DIO_VidSetPinDirection+0x190>
 298:	88 0f       	add	r24, r24
 29a:	99 1f       	adc	r25, r25
 29c:	0a 94       	dec	r0
 29e:	e2 f7       	brpl	.-8      	; 0x298 <DIO_VidSetPinDirection+0x18c>
 2a0:	80 95       	com	r24
 2a2:	84 23       	and	r24, r20
 2a4:	8c 93       	st	X, r24
 2a6:	29 c0       	rjmp	.+82     	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
            case 2 : CLR_BIT(DDRC,Copy_U8Pin); break;
 2a8:	a4 e3       	ldi	r26, 0x34	; 52
 2aa:	b0 e0       	ldi	r27, 0x00	; 0
 2ac:	e4 e3       	ldi	r30, 0x34	; 52
 2ae:	f0 e0       	ldi	r31, 0x00	; 0
 2b0:	80 81       	ld	r24, Z
 2b2:	48 2f       	mov	r20, r24
 2b4:	8a 81       	ldd	r24, Y+2	; 0x02
 2b6:	28 2f       	mov	r18, r24
 2b8:	30 e0       	ldi	r19, 0x00	; 0
 2ba:	81 e0       	ldi	r24, 0x01	; 1
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	02 2e       	mov	r0, r18
 2c0:	02 c0       	rjmp	.+4      	; 0x2c6 <DIO_VidSetPinDirection+0x1ba>
 2c2:	88 0f       	add	r24, r24
 2c4:	99 1f       	adc	r25, r25
 2c6:	0a 94       	dec	r0
 2c8:	e2 f7       	brpl	.-8      	; 0x2c2 <DIO_VidSetPinDirection+0x1b6>
 2ca:	80 95       	com	r24
 2cc:	84 23       	and	r24, r20
 2ce:	8c 93       	st	X, r24
 2d0:	14 c0       	rjmp	.+40     	; 0x2fa <DIO_VidSetPinDirection+0x1ee>
            case 3 : CLR_BIT(DDRD,Copy_U8Pin); break;
 2d2:	a1 e3       	ldi	r26, 0x31	; 49
 2d4:	b0 e0       	ldi	r27, 0x00	; 0
 2d6:	e1 e3       	ldi	r30, 0x31	; 49
 2d8:	f0 e0       	ldi	r31, 0x00	; 0
 2da:	80 81       	ld	r24, Z
 2dc:	48 2f       	mov	r20, r24
 2de:	8a 81       	ldd	r24, Y+2	; 0x02
 2e0:	28 2f       	mov	r18, r24
 2e2:	30 e0       	ldi	r19, 0x00	; 0
 2e4:	81 e0       	ldi	r24, 0x01	; 1
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	02 2e       	mov	r0, r18
 2ea:	02 c0       	rjmp	.+4      	; 0x2f0 <DIO_VidSetPinDirection+0x1e4>
 2ec:	88 0f       	add	r24, r24
 2ee:	99 1f       	adc	r25, r25
 2f0:	0a 94       	dec	r0
 2f2:	e2 f7       	brpl	.-8      	; 0x2ec <DIO_VidSetPinDirection+0x1e0>
 2f4:	80 95       	com	r24
 2f6:	84 23       	and	r24, r20
 2f8:	8c 93       	st	X, r24
    }
    else
    {

    }
}
 2fa:	27 96       	adiw	r28, 0x07	; 7
 2fc:	0f b6       	in	r0, 0x3f	; 63
 2fe:	f8 94       	cli
 300:	de bf       	out	0x3e, r29	; 62
 302:	0f be       	out	0x3f, r0	; 63
 304:	cd bf       	out	0x3d, r28	; 61
 306:	cf 91       	pop	r28
 308:	df 91       	pop	r29
 30a:	08 95       	ret

0000030c <DIO_VidSetPortValue>:

void DIO_VidSetPortValue(u8 Copy_U8Port, u8 Copy_U8Value)
{
 30c:	df 93       	push	r29
 30e:	cf 93       	push	r28
 310:	00 d0       	rcall	.+0      	; 0x312 <DIO_VidSetPortValue+0x6>
 312:	00 d0       	rcall	.+0      	; 0x314 <DIO_VidSetPortValue+0x8>
 314:	cd b7       	in	r28, 0x3d	; 61
 316:	de b7       	in	r29, 0x3e	; 62
 318:	89 83       	std	Y+1, r24	; 0x01
 31a:	6a 83       	std	Y+2, r22	; 0x02
    switch(Copy_U8Port)
 31c:	89 81       	ldd	r24, Y+1	; 0x01
 31e:	28 2f       	mov	r18, r24
 320:	30 e0       	ldi	r19, 0x00	; 0
 322:	3c 83       	std	Y+4, r19	; 0x04
 324:	2b 83       	std	Y+3, r18	; 0x03
 326:	8b 81       	ldd	r24, Y+3	; 0x03
 328:	9c 81       	ldd	r25, Y+4	; 0x04
 32a:	81 30       	cpi	r24, 0x01	; 1
 32c:	91 05       	cpc	r25, r1
 32e:	d1 f0       	breq	.+52     	; 0x364 <DIO_VidSetPortValue+0x58>
 330:	2b 81       	ldd	r18, Y+3	; 0x03
 332:	3c 81       	ldd	r19, Y+4	; 0x04
 334:	22 30       	cpi	r18, 0x02	; 2
 336:	31 05       	cpc	r19, r1
 338:	2c f4       	brge	.+10     	; 0x344 <DIO_VidSetPortValue+0x38>
 33a:	8b 81       	ldd	r24, Y+3	; 0x03
 33c:	9c 81       	ldd	r25, Y+4	; 0x04
 33e:	00 97       	sbiw	r24, 0x00	; 0
 340:	61 f0       	breq	.+24     	; 0x35a <DIO_VidSetPortValue+0x4e>
 342:	1e c0       	rjmp	.+60     	; 0x380 <DIO_VidSetPortValue+0x74>
 344:	2b 81       	ldd	r18, Y+3	; 0x03
 346:	3c 81       	ldd	r19, Y+4	; 0x04
 348:	22 30       	cpi	r18, 0x02	; 2
 34a:	31 05       	cpc	r19, r1
 34c:	81 f0       	breq	.+32     	; 0x36e <DIO_VidSetPortValue+0x62>
 34e:	8b 81       	ldd	r24, Y+3	; 0x03
 350:	9c 81       	ldd	r25, Y+4	; 0x04
 352:	83 30       	cpi	r24, 0x03	; 3
 354:	91 05       	cpc	r25, r1
 356:	81 f0       	breq	.+32     	; 0x378 <DIO_VidSetPortValue+0x6c>
 358:	13 c0       	rjmp	.+38     	; 0x380 <DIO_VidSetPortValue+0x74>
    {
        case 0 :    PORTA = Copy_U8Value; break;
 35a:	eb e3       	ldi	r30, 0x3B	; 59
 35c:	f0 e0       	ldi	r31, 0x00	; 0
 35e:	8a 81       	ldd	r24, Y+2	; 0x02
 360:	80 83       	st	Z, r24
 362:	0e c0       	rjmp	.+28     	; 0x380 <DIO_VidSetPortValue+0x74>
        case 1 :    PORTB = Copy_U8Value; break;
 364:	e8 e3       	ldi	r30, 0x38	; 56
 366:	f0 e0       	ldi	r31, 0x00	; 0
 368:	8a 81       	ldd	r24, Y+2	; 0x02
 36a:	80 83       	st	Z, r24
 36c:	09 c0       	rjmp	.+18     	; 0x380 <DIO_VidSetPortValue+0x74>
        case 2 :    PORTC = Copy_U8Value; break;
 36e:	e5 e3       	ldi	r30, 0x35	; 53
 370:	f0 e0       	ldi	r31, 0x00	; 0
 372:	8a 81       	ldd	r24, Y+2	; 0x02
 374:	80 83       	st	Z, r24
 376:	04 c0       	rjmp	.+8      	; 0x380 <DIO_VidSetPortValue+0x74>
        case 3 :    PORTD = Copy_U8Value; break;
 378:	e2 e3       	ldi	r30, 0x32	; 50
 37a:	f0 e0       	ldi	r31, 0x00	; 0
 37c:	8a 81       	ldd	r24, Y+2	; 0x02
 37e:	80 83       	st	Z, r24
    }
}
 380:	0f 90       	pop	r0
 382:	0f 90       	pop	r0
 384:	0f 90       	pop	r0
 386:	0f 90       	pop	r0
 388:	cf 91       	pop	r28
 38a:	df 91       	pop	r29
 38c:	08 95       	ret

0000038e <DIO_VidSetPinValue>:

void DIO_VidSetPinValue(u8 Copy_U8Port, u8 Copy_U8Pin , u8 Copy_U8Value)
{
 38e:	df 93       	push	r29
 390:	cf 93       	push	r28
 392:	cd b7       	in	r28, 0x3d	; 61
 394:	de b7       	in	r29, 0x3e	; 62
 396:	27 97       	sbiw	r28, 0x07	; 7
 398:	0f b6       	in	r0, 0x3f	; 63
 39a:	f8 94       	cli
 39c:	de bf       	out	0x3e, r29	; 62
 39e:	0f be       	out	0x3f, r0	; 63
 3a0:	cd bf       	out	0x3d, r28	; 61
 3a2:	89 83       	std	Y+1, r24	; 0x01
 3a4:	6a 83       	std	Y+2, r22	; 0x02
 3a6:	4b 83       	std	Y+3, r20	; 0x03
    if (1 == Copy_U8Value)
 3a8:	8b 81       	ldd	r24, Y+3	; 0x03
 3aa:	81 30       	cpi	r24, 0x01	; 1
 3ac:	09 f0       	breq	.+2      	; 0x3b0 <DIO_VidSetPinValue+0x22>
 3ae:	6f c0       	rjmp	.+222    	; 0x48e <DIO_VidSetPinValue+0x100>
    {
        switch(Copy_U8Port)
 3b0:	89 81       	ldd	r24, Y+1	; 0x01
 3b2:	28 2f       	mov	r18, r24
 3b4:	30 e0       	ldi	r19, 0x00	; 0
 3b6:	3f 83       	std	Y+7, r19	; 0x07
 3b8:	2e 83       	std	Y+6, r18	; 0x06
 3ba:	8e 81       	ldd	r24, Y+6	; 0x06
 3bc:	9f 81       	ldd	r25, Y+7	; 0x07
 3be:	81 30       	cpi	r24, 0x01	; 1
 3c0:	91 05       	cpc	r25, r1
 3c2:	49 f1       	breq	.+82     	; 0x416 <DIO_VidSetPinValue+0x88>
 3c4:	2e 81       	ldd	r18, Y+6	; 0x06
 3c6:	3f 81       	ldd	r19, Y+7	; 0x07
 3c8:	22 30       	cpi	r18, 0x02	; 2
 3ca:	31 05       	cpc	r19, r1
 3cc:	2c f4       	brge	.+10     	; 0x3d8 <DIO_VidSetPinValue+0x4a>
 3ce:	8e 81       	ldd	r24, Y+6	; 0x06
 3d0:	9f 81       	ldd	r25, Y+7	; 0x07
 3d2:	00 97       	sbiw	r24, 0x00	; 0
 3d4:	61 f0       	breq	.+24     	; 0x3ee <DIO_VidSetPinValue+0x60>
 3d6:	d2 c0       	rjmp	.+420    	; 0x57c <DIO_VidSetPinValue+0x1ee>
 3d8:	2e 81       	ldd	r18, Y+6	; 0x06
 3da:	3f 81       	ldd	r19, Y+7	; 0x07
 3dc:	22 30       	cpi	r18, 0x02	; 2
 3de:	31 05       	cpc	r19, r1
 3e0:	71 f1       	breq	.+92     	; 0x43e <DIO_VidSetPinValue+0xb0>
 3e2:	8e 81       	ldd	r24, Y+6	; 0x06
 3e4:	9f 81       	ldd	r25, Y+7	; 0x07
 3e6:	83 30       	cpi	r24, 0x03	; 3
 3e8:	91 05       	cpc	r25, r1
 3ea:	e9 f1       	breq	.+122    	; 0x466 <DIO_VidSetPinValue+0xd8>
 3ec:	c7 c0       	rjmp	.+398    	; 0x57c <DIO_VidSetPinValue+0x1ee>
        {
            case 0 : SET_BIT(PORTA,Copy_U8Pin); break;
 3ee:	ab e3       	ldi	r26, 0x3B	; 59
 3f0:	b0 e0       	ldi	r27, 0x00	; 0
 3f2:	eb e3       	ldi	r30, 0x3B	; 59
 3f4:	f0 e0       	ldi	r31, 0x00	; 0
 3f6:	80 81       	ld	r24, Z
 3f8:	48 2f       	mov	r20, r24
 3fa:	8a 81       	ldd	r24, Y+2	; 0x02
 3fc:	28 2f       	mov	r18, r24
 3fe:	30 e0       	ldi	r19, 0x00	; 0
 400:	81 e0       	ldi	r24, 0x01	; 1
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	02 2e       	mov	r0, r18
 406:	02 c0       	rjmp	.+4      	; 0x40c <DIO_VidSetPinValue+0x7e>
 408:	88 0f       	add	r24, r24
 40a:	99 1f       	adc	r25, r25
 40c:	0a 94       	dec	r0
 40e:	e2 f7       	brpl	.-8      	; 0x408 <DIO_VidSetPinValue+0x7a>
 410:	84 2b       	or	r24, r20
 412:	8c 93       	st	X, r24
 414:	b3 c0       	rjmp	.+358    	; 0x57c <DIO_VidSetPinValue+0x1ee>
            case 1 : SET_BIT(PORTB,Copy_U8Pin); break;
 416:	a8 e3       	ldi	r26, 0x38	; 56
 418:	b0 e0       	ldi	r27, 0x00	; 0
 41a:	e8 e3       	ldi	r30, 0x38	; 56
 41c:	f0 e0       	ldi	r31, 0x00	; 0
 41e:	80 81       	ld	r24, Z
 420:	48 2f       	mov	r20, r24
 422:	8a 81       	ldd	r24, Y+2	; 0x02
 424:	28 2f       	mov	r18, r24
 426:	30 e0       	ldi	r19, 0x00	; 0
 428:	81 e0       	ldi	r24, 0x01	; 1
 42a:	90 e0       	ldi	r25, 0x00	; 0
 42c:	02 2e       	mov	r0, r18
 42e:	02 c0       	rjmp	.+4      	; 0x434 <DIO_VidSetPinValue+0xa6>
 430:	88 0f       	add	r24, r24
 432:	99 1f       	adc	r25, r25
 434:	0a 94       	dec	r0
 436:	e2 f7       	brpl	.-8      	; 0x430 <DIO_VidSetPinValue+0xa2>
 438:	84 2b       	or	r24, r20
 43a:	8c 93       	st	X, r24
 43c:	9f c0       	rjmp	.+318    	; 0x57c <DIO_VidSetPinValue+0x1ee>
            case 2 : SET_BIT(PORTC,Copy_U8Pin); break;
 43e:	a5 e3       	ldi	r26, 0x35	; 53
 440:	b0 e0       	ldi	r27, 0x00	; 0
 442:	e5 e3       	ldi	r30, 0x35	; 53
 444:	f0 e0       	ldi	r31, 0x00	; 0
 446:	80 81       	ld	r24, Z
 448:	48 2f       	mov	r20, r24
 44a:	8a 81       	ldd	r24, Y+2	; 0x02
 44c:	28 2f       	mov	r18, r24
 44e:	30 e0       	ldi	r19, 0x00	; 0
 450:	81 e0       	ldi	r24, 0x01	; 1
 452:	90 e0       	ldi	r25, 0x00	; 0
 454:	02 2e       	mov	r0, r18
 456:	02 c0       	rjmp	.+4      	; 0x45c <DIO_VidSetPinValue+0xce>
 458:	88 0f       	add	r24, r24
 45a:	99 1f       	adc	r25, r25
 45c:	0a 94       	dec	r0
 45e:	e2 f7       	brpl	.-8      	; 0x458 <DIO_VidSetPinValue+0xca>
 460:	84 2b       	or	r24, r20
 462:	8c 93       	st	X, r24
 464:	8b c0       	rjmp	.+278    	; 0x57c <DIO_VidSetPinValue+0x1ee>
            case 3 : SET_BIT(PORTD,Copy_U8Pin); break;            
 466:	a2 e3       	ldi	r26, 0x32	; 50
 468:	b0 e0       	ldi	r27, 0x00	; 0
 46a:	e2 e3       	ldi	r30, 0x32	; 50
 46c:	f0 e0       	ldi	r31, 0x00	; 0
 46e:	80 81       	ld	r24, Z
 470:	48 2f       	mov	r20, r24
 472:	8a 81       	ldd	r24, Y+2	; 0x02
 474:	28 2f       	mov	r18, r24
 476:	30 e0       	ldi	r19, 0x00	; 0
 478:	81 e0       	ldi	r24, 0x01	; 1
 47a:	90 e0       	ldi	r25, 0x00	; 0
 47c:	02 2e       	mov	r0, r18
 47e:	02 c0       	rjmp	.+4      	; 0x484 <DIO_VidSetPinValue+0xf6>
 480:	88 0f       	add	r24, r24
 482:	99 1f       	adc	r25, r25
 484:	0a 94       	dec	r0
 486:	e2 f7       	brpl	.-8      	; 0x480 <DIO_VidSetPinValue+0xf2>
 488:	84 2b       	or	r24, r20
 48a:	8c 93       	st	X, r24
 48c:	77 c0       	rjmp	.+238    	; 0x57c <DIO_VidSetPinValue+0x1ee>
        }
    }
    else if (0== Copy_U8Value)
 48e:	8b 81       	ldd	r24, Y+3	; 0x03
 490:	88 23       	and	r24, r24
 492:	09 f0       	breq	.+2      	; 0x496 <DIO_VidSetPinValue+0x108>
 494:	73 c0       	rjmp	.+230    	; 0x57c <DIO_VidSetPinValue+0x1ee>
    {
        switch (Copy_U8Port)
 496:	89 81       	ldd	r24, Y+1	; 0x01
 498:	28 2f       	mov	r18, r24
 49a:	30 e0       	ldi	r19, 0x00	; 0
 49c:	3d 83       	std	Y+5, r19	; 0x05
 49e:	2c 83       	std	Y+4, r18	; 0x04
 4a0:	8c 81       	ldd	r24, Y+4	; 0x04
 4a2:	9d 81       	ldd	r25, Y+5	; 0x05
 4a4:	81 30       	cpi	r24, 0x01	; 1
 4a6:	91 05       	cpc	r25, r1
 4a8:	59 f1       	breq	.+86     	; 0x500 <DIO_VidSetPinValue+0x172>
 4aa:	2c 81       	ldd	r18, Y+4	; 0x04
 4ac:	3d 81       	ldd	r19, Y+5	; 0x05
 4ae:	22 30       	cpi	r18, 0x02	; 2
 4b0:	31 05       	cpc	r19, r1
 4b2:	2c f4       	brge	.+10     	; 0x4be <DIO_VidSetPinValue+0x130>
 4b4:	8c 81       	ldd	r24, Y+4	; 0x04
 4b6:	9d 81       	ldd	r25, Y+5	; 0x05
 4b8:	00 97       	sbiw	r24, 0x00	; 0
 4ba:	69 f0       	breq	.+26     	; 0x4d6 <DIO_VidSetPinValue+0x148>
 4bc:	5f c0       	rjmp	.+190    	; 0x57c <DIO_VidSetPinValue+0x1ee>
 4be:	2c 81       	ldd	r18, Y+4	; 0x04
 4c0:	3d 81       	ldd	r19, Y+5	; 0x05
 4c2:	22 30       	cpi	r18, 0x02	; 2
 4c4:	31 05       	cpc	r19, r1
 4c6:	89 f1       	breq	.+98     	; 0x52a <DIO_VidSetPinValue+0x19c>
 4c8:	8c 81       	ldd	r24, Y+4	; 0x04
 4ca:	9d 81       	ldd	r25, Y+5	; 0x05
 4cc:	83 30       	cpi	r24, 0x03	; 3
 4ce:	91 05       	cpc	r25, r1
 4d0:	09 f4       	brne	.+2      	; 0x4d4 <DIO_VidSetPinValue+0x146>
 4d2:	40 c0       	rjmp	.+128    	; 0x554 <DIO_VidSetPinValue+0x1c6>
 4d4:	53 c0       	rjmp	.+166    	; 0x57c <DIO_VidSetPinValue+0x1ee>
        {
            case 0 : CLR_BIT(PORTA,Copy_U8Pin); break;
 4d6:	ab e3       	ldi	r26, 0x3B	; 59
 4d8:	b0 e0       	ldi	r27, 0x00	; 0
 4da:	eb e3       	ldi	r30, 0x3B	; 59
 4dc:	f0 e0       	ldi	r31, 0x00	; 0
 4de:	80 81       	ld	r24, Z
 4e0:	48 2f       	mov	r20, r24
 4e2:	8a 81       	ldd	r24, Y+2	; 0x02
 4e4:	28 2f       	mov	r18, r24
 4e6:	30 e0       	ldi	r19, 0x00	; 0
 4e8:	81 e0       	ldi	r24, 0x01	; 1
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	02 2e       	mov	r0, r18
 4ee:	02 c0       	rjmp	.+4      	; 0x4f4 <DIO_VidSetPinValue+0x166>
 4f0:	88 0f       	add	r24, r24
 4f2:	99 1f       	adc	r25, r25
 4f4:	0a 94       	dec	r0
 4f6:	e2 f7       	brpl	.-8      	; 0x4f0 <DIO_VidSetPinValue+0x162>
 4f8:	80 95       	com	r24
 4fa:	84 23       	and	r24, r20
 4fc:	8c 93       	st	X, r24
 4fe:	3e c0       	rjmp	.+124    	; 0x57c <DIO_VidSetPinValue+0x1ee>
            case 1 : CLR_BIT(PORTB,Copy_U8Pin); break;
 500:	a8 e3       	ldi	r26, 0x38	; 56
 502:	b0 e0       	ldi	r27, 0x00	; 0
 504:	e8 e3       	ldi	r30, 0x38	; 56
 506:	f0 e0       	ldi	r31, 0x00	; 0
 508:	80 81       	ld	r24, Z
 50a:	48 2f       	mov	r20, r24
 50c:	8a 81       	ldd	r24, Y+2	; 0x02
 50e:	28 2f       	mov	r18, r24
 510:	30 e0       	ldi	r19, 0x00	; 0
 512:	81 e0       	ldi	r24, 0x01	; 1
 514:	90 e0       	ldi	r25, 0x00	; 0
 516:	02 2e       	mov	r0, r18
 518:	02 c0       	rjmp	.+4      	; 0x51e <DIO_VidSetPinValue+0x190>
 51a:	88 0f       	add	r24, r24
 51c:	99 1f       	adc	r25, r25
 51e:	0a 94       	dec	r0
 520:	e2 f7       	brpl	.-8      	; 0x51a <DIO_VidSetPinValue+0x18c>
 522:	80 95       	com	r24
 524:	84 23       	and	r24, r20
 526:	8c 93       	st	X, r24
 528:	29 c0       	rjmp	.+82     	; 0x57c <DIO_VidSetPinValue+0x1ee>
            case 2 : CLR_BIT(PORTC,Copy_U8Pin); break;
 52a:	a5 e3       	ldi	r26, 0x35	; 53
 52c:	b0 e0       	ldi	r27, 0x00	; 0
 52e:	e5 e3       	ldi	r30, 0x35	; 53
 530:	f0 e0       	ldi	r31, 0x00	; 0
 532:	80 81       	ld	r24, Z
 534:	48 2f       	mov	r20, r24
 536:	8a 81       	ldd	r24, Y+2	; 0x02
 538:	28 2f       	mov	r18, r24
 53a:	30 e0       	ldi	r19, 0x00	; 0
 53c:	81 e0       	ldi	r24, 0x01	; 1
 53e:	90 e0       	ldi	r25, 0x00	; 0
 540:	02 2e       	mov	r0, r18
 542:	02 c0       	rjmp	.+4      	; 0x548 <DIO_VidSetPinValue+0x1ba>
 544:	88 0f       	add	r24, r24
 546:	99 1f       	adc	r25, r25
 548:	0a 94       	dec	r0
 54a:	e2 f7       	brpl	.-8      	; 0x544 <DIO_VidSetPinValue+0x1b6>
 54c:	80 95       	com	r24
 54e:	84 23       	and	r24, r20
 550:	8c 93       	st	X, r24
 552:	14 c0       	rjmp	.+40     	; 0x57c <DIO_VidSetPinValue+0x1ee>
            case 3 : CLR_BIT(PORTD,Copy_U8Pin); break;
 554:	a2 e3       	ldi	r26, 0x32	; 50
 556:	b0 e0       	ldi	r27, 0x00	; 0
 558:	e2 e3       	ldi	r30, 0x32	; 50
 55a:	f0 e0       	ldi	r31, 0x00	; 0
 55c:	80 81       	ld	r24, Z
 55e:	48 2f       	mov	r20, r24
 560:	8a 81       	ldd	r24, Y+2	; 0x02
 562:	28 2f       	mov	r18, r24
 564:	30 e0       	ldi	r19, 0x00	; 0
 566:	81 e0       	ldi	r24, 0x01	; 1
 568:	90 e0       	ldi	r25, 0x00	; 0
 56a:	02 2e       	mov	r0, r18
 56c:	02 c0       	rjmp	.+4      	; 0x572 <DIO_VidSetPinValue+0x1e4>
 56e:	88 0f       	add	r24, r24
 570:	99 1f       	adc	r25, r25
 572:	0a 94       	dec	r0
 574:	e2 f7       	brpl	.-8      	; 0x56e <DIO_VidSetPinValue+0x1e0>
 576:	80 95       	com	r24
 578:	84 23       	and	r24, r20
 57a:	8c 93       	st	X, r24
        } 
    }
}
 57c:	27 96       	adiw	r28, 0x07	; 7
 57e:	0f b6       	in	r0, 0x3f	; 63
 580:	f8 94       	cli
 582:	de bf       	out	0x3e, r29	; 62
 584:	0f be       	out	0x3f, r0	; 63
 586:	cd bf       	out	0x3d, r28	; 61
 588:	cf 91       	pop	r28
 58a:	df 91       	pop	r29
 58c:	08 95       	ret

0000058e <DIO_VidTogglePin>:

void DIO_VidTogglePin(u8 Copy_U8Port, u8 Copy_U8Pin)
{
 58e:	df 93       	push	r29
 590:	cf 93       	push	r28
 592:	00 d0       	rcall	.+0      	; 0x594 <DIO_VidTogglePin+0x6>
 594:	00 d0       	rcall	.+0      	; 0x596 <DIO_VidTogglePin+0x8>
 596:	cd b7       	in	r28, 0x3d	; 61
 598:	de b7       	in	r29, 0x3e	; 62
 59a:	89 83       	std	Y+1, r24	; 0x01
 59c:	6a 83       	std	Y+2, r22	; 0x02
    switch (Copy_U8Port)
 59e:	89 81       	ldd	r24, Y+1	; 0x01
 5a0:	28 2f       	mov	r18, r24
 5a2:	30 e0       	ldi	r19, 0x00	; 0
 5a4:	3c 83       	std	Y+4, r19	; 0x04
 5a6:	2b 83       	std	Y+3, r18	; 0x03
 5a8:	8b 81       	ldd	r24, Y+3	; 0x03
 5aa:	9c 81       	ldd	r25, Y+4	; 0x04
 5ac:	81 30       	cpi	r24, 0x01	; 1
 5ae:	91 05       	cpc	r25, r1
 5b0:	49 f1       	breq	.+82     	; 0x604 <DIO_VidTogglePin+0x76>
 5b2:	2b 81       	ldd	r18, Y+3	; 0x03
 5b4:	3c 81       	ldd	r19, Y+4	; 0x04
 5b6:	22 30       	cpi	r18, 0x02	; 2
 5b8:	31 05       	cpc	r19, r1
 5ba:	2c f4       	brge	.+10     	; 0x5c6 <DIO_VidTogglePin+0x38>
 5bc:	8b 81       	ldd	r24, Y+3	; 0x03
 5be:	9c 81       	ldd	r25, Y+4	; 0x04
 5c0:	00 97       	sbiw	r24, 0x00	; 0
 5c2:	61 f0       	breq	.+24     	; 0x5dc <DIO_VidTogglePin+0x4e>
 5c4:	5a c0       	rjmp	.+180    	; 0x67a <DIO_VidTogglePin+0xec>
 5c6:	2b 81       	ldd	r18, Y+3	; 0x03
 5c8:	3c 81       	ldd	r19, Y+4	; 0x04
 5ca:	22 30       	cpi	r18, 0x02	; 2
 5cc:	31 05       	cpc	r19, r1
 5ce:	71 f1       	breq	.+92     	; 0x62c <DIO_VidTogglePin+0x9e>
 5d0:	8b 81       	ldd	r24, Y+3	; 0x03
 5d2:	9c 81       	ldd	r25, Y+4	; 0x04
 5d4:	83 30       	cpi	r24, 0x03	; 3
 5d6:	91 05       	cpc	r25, r1
 5d8:	e9 f1       	breq	.+122    	; 0x654 <DIO_VidTogglePin+0xc6>
 5da:	4f c0       	rjmp	.+158    	; 0x67a <DIO_VidTogglePin+0xec>
    {
        case 0 : TOGGLE_BIT(PORTA,Copy_U8Pin); break;
 5dc:	ab e3       	ldi	r26, 0x3B	; 59
 5de:	b0 e0       	ldi	r27, 0x00	; 0
 5e0:	eb e3       	ldi	r30, 0x3B	; 59
 5e2:	f0 e0       	ldi	r31, 0x00	; 0
 5e4:	80 81       	ld	r24, Z
 5e6:	48 2f       	mov	r20, r24
 5e8:	8a 81       	ldd	r24, Y+2	; 0x02
 5ea:	28 2f       	mov	r18, r24
 5ec:	30 e0       	ldi	r19, 0x00	; 0
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	90 e0       	ldi	r25, 0x00	; 0
 5f2:	02 2e       	mov	r0, r18
 5f4:	02 c0       	rjmp	.+4      	; 0x5fa <DIO_VidTogglePin+0x6c>
 5f6:	88 0f       	add	r24, r24
 5f8:	99 1f       	adc	r25, r25
 5fa:	0a 94       	dec	r0
 5fc:	e2 f7       	brpl	.-8      	; 0x5f6 <DIO_VidTogglePin+0x68>
 5fe:	84 27       	eor	r24, r20
 600:	8c 93       	st	X, r24
 602:	3b c0       	rjmp	.+118    	; 0x67a <DIO_VidTogglePin+0xec>
        case 1 : TOGGLE_BIT(PORTB,Copy_U8Pin); break;
 604:	a8 e3       	ldi	r26, 0x38	; 56
 606:	b0 e0       	ldi	r27, 0x00	; 0
 608:	e8 e3       	ldi	r30, 0x38	; 56
 60a:	f0 e0       	ldi	r31, 0x00	; 0
 60c:	80 81       	ld	r24, Z
 60e:	48 2f       	mov	r20, r24
 610:	8a 81       	ldd	r24, Y+2	; 0x02
 612:	28 2f       	mov	r18, r24
 614:	30 e0       	ldi	r19, 0x00	; 0
 616:	81 e0       	ldi	r24, 0x01	; 1
 618:	90 e0       	ldi	r25, 0x00	; 0
 61a:	02 2e       	mov	r0, r18
 61c:	02 c0       	rjmp	.+4      	; 0x622 <DIO_VidTogglePin+0x94>
 61e:	88 0f       	add	r24, r24
 620:	99 1f       	adc	r25, r25
 622:	0a 94       	dec	r0
 624:	e2 f7       	brpl	.-8      	; 0x61e <DIO_VidTogglePin+0x90>
 626:	84 27       	eor	r24, r20
 628:	8c 93       	st	X, r24
 62a:	27 c0       	rjmp	.+78     	; 0x67a <DIO_VidTogglePin+0xec>
        case 2 : TOGGLE_BIT(PORTC,Copy_U8Pin); break;
 62c:	a5 e3       	ldi	r26, 0x35	; 53
 62e:	b0 e0       	ldi	r27, 0x00	; 0
 630:	e5 e3       	ldi	r30, 0x35	; 53
 632:	f0 e0       	ldi	r31, 0x00	; 0
 634:	80 81       	ld	r24, Z
 636:	48 2f       	mov	r20, r24
 638:	8a 81       	ldd	r24, Y+2	; 0x02
 63a:	28 2f       	mov	r18, r24
 63c:	30 e0       	ldi	r19, 0x00	; 0
 63e:	81 e0       	ldi	r24, 0x01	; 1
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	02 2e       	mov	r0, r18
 644:	02 c0       	rjmp	.+4      	; 0x64a <DIO_VidTogglePin+0xbc>
 646:	88 0f       	add	r24, r24
 648:	99 1f       	adc	r25, r25
 64a:	0a 94       	dec	r0
 64c:	e2 f7       	brpl	.-8      	; 0x646 <DIO_VidTogglePin+0xb8>
 64e:	84 27       	eor	r24, r20
 650:	8c 93       	st	X, r24
 652:	13 c0       	rjmp	.+38     	; 0x67a <DIO_VidTogglePin+0xec>
        case 3 : TOGGLE_BIT(PORTD,Copy_U8Pin); break;
 654:	a2 e3       	ldi	r26, 0x32	; 50
 656:	b0 e0       	ldi	r27, 0x00	; 0
 658:	e2 e3       	ldi	r30, 0x32	; 50
 65a:	f0 e0       	ldi	r31, 0x00	; 0
 65c:	80 81       	ld	r24, Z
 65e:	48 2f       	mov	r20, r24
 660:	8a 81       	ldd	r24, Y+2	; 0x02
 662:	28 2f       	mov	r18, r24
 664:	30 e0       	ldi	r19, 0x00	; 0
 666:	81 e0       	ldi	r24, 0x01	; 1
 668:	90 e0       	ldi	r25, 0x00	; 0
 66a:	02 2e       	mov	r0, r18
 66c:	02 c0       	rjmp	.+4      	; 0x672 <DIO_VidTogglePin+0xe4>
 66e:	88 0f       	add	r24, r24
 670:	99 1f       	adc	r25, r25
 672:	0a 94       	dec	r0
 674:	e2 f7       	brpl	.-8      	; 0x66e <DIO_VidTogglePin+0xe0>
 676:	84 27       	eor	r24, r20
 678:	8c 93       	st	X, r24
    } 
}
 67a:	0f 90       	pop	r0
 67c:	0f 90       	pop	r0
 67e:	0f 90       	pop	r0
 680:	0f 90       	pop	r0
 682:	cf 91       	pop	r28
 684:	df 91       	pop	r29
 686:	08 95       	ret

00000688 <DIO_U8GetPinValue>:

u8 DIO_U8GetPinValue(u8 Copy_U8Port, u8 Copy_U8Pin)
{
 688:	df 93       	push	r29
 68a:	cf 93       	push	r28
 68c:	00 d0       	rcall	.+0      	; 0x68e <DIO_U8GetPinValue+0x6>
 68e:	00 d0       	rcall	.+0      	; 0x690 <DIO_U8GetPinValue+0x8>
 690:	0f 92       	push	r0
 692:	cd b7       	in	r28, 0x3d	; 61
 694:	de b7       	in	r29, 0x3e	; 62
 696:	8a 83       	std	Y+2, r24	; 0x02
 698:	6b 83       	std	Y+3, r22	; 0x03
    u8 Local_U8Value;
    switch (Copy_U8Port)
 69a:	8a 81       	ldd	r24, Y+2	; 0x02
 69c:	28 2f       	mov	r18, r24
 69e:	30 e0       	ldi	r19, 0x00	; 0
 6a0:	3d 83       	std	Y+5, r19	; 0x05
 6a2:	2c 83       	std	Y+4, r18	; 0x04
 6a4:	4c 81       	ldd	r20, Y+4	; 0x04
 6a6:	5d 81       	ldd	r21, Y+5	; 0x05
 6a8:	41 30       	cpi	r20, 0x01	; 1
 6aa:	51 05       	cpc	r21, r1
 6ac:	41 f1       	breq	.+80     	; 0x6fe <DIO_U8GetPinValue+0x76>
 6ae:	8c 81       	ldd	r24, Y+4	; 0x04
 6b0:	9d 81       	ldd	r25, Y+5	; 0x05
 6b2:	82 30       	cpi	r24, 0x02	; 2
 6b4:	91 05       	cpc	r25, r1
 6b6:	34 f4       	brge	.+12     	; 0x6c4 <DIO_U8GetPinValue+0x3c>
 6b8:	2c 81       	ldd	r18, Y+4	; 0x04
 6ba:	3d 81       	ldd	r19, Y+5	; 0x05
 6bc:	21 15       	cp	r18, r1
 6be:	31 05       	cpc	r19, r1
 6c0:	61 f0       	breq	.+24     	; 0x6da <DIO_U8GetPinValue+0x52>
 6c2:	52 c0       	rjmp	.+164    	; 0x768 <DIO_U8GetPinValue+0xe0>
 6c4:	4c 81       	ldd	r20, Y+4	; 0x04
 6c6:	5d 81       	ldd	r21, Y+5	; 0x05
 6c8:	42 30       	cpi	r20, 0x02	; 2
 6ca:	51 05       	cpc	r21, r1
 6cc:	51 f1       	breq	.+84     	; 0x722 <DIO_U8GetPinValue+0x9a>
 6ce:	8c 81       	ldd	r24, Y+4	; 0x04
 6d0:	9d 81       	ldd	r25, Y+5	; 0x05
 6d2:	83 30       	cpi	r24, 0x03	; 3
 6d4:	91 05       	cpc	r25, r1
 6d6:	b9 f1       	breq	.+110    	; 0x746 <DIO_U8GetPinValue+0xbe>
 6d8:	47 c0       	rjmp	.+142    	; 0x768 <DIO_U8GetPinValue+0xe0>
    {
        case 0 : Local_U8Value = GET_BIT(PINA,Copy_U8Pin); break;
 6da:	e9 e3       	ldi	r30, 0x39	; 57
 6dc:	f0 e0       	ldi	r31, 0x00	; 0
 6de:	80 81       	ld	r24, Z
 6e0:	28 2f       	mov	r18, r24
 6e2:	30 e0       	ldi	r19, 0x00	; 0
 6e4:	8b 81       	ldd	r24, Y+3	; 0x03
 6e6:	88 2f       	mov	r24, r24
 6e8:	90 e0       	ldi	r25, 0x00	; 0
 6ea:	a9 01       	movw	r20, r18
 6ec:	02 c0       	rjmp	.+4      	; 0x6f2 <DIO_U8GetPinValue+0x6a>
 6ee:	55 95       	asr	r21
 6f0:	47 95       	ror	r20
 6f2:	8a 95       	dec	r24
 6f4:	e2 f7       	brpl	.-8      	; 0x6ee <DIO_U8GetPinValue+0x66>
 6f6:	ca 01       	movw	r24, r20
 6f8:	81 70       	andi	r24, 0x01	; 1
 6fa:	89 83       	std	Y+1, r24	; 0x01
 6fc:	35 c0       	rjmp	.+106    	; 0x768 <DIO_U8GetPinValue+0xe0>
        case 1 : Local_U8Value = GET_BIT(PINB,Copy_U8Pin); break;
 6fe:	e6 e3       	ldi	r30, 0x36	; 54
 700:	f0 e0       	ldi	r31, 0x00	; 0
 702:	80 81       	ld	r24, Z
 704:	28 2f       	mov	r18, r24
 706:	30 e0       	ldi	r19, 0x00	; 0
 708:	8b 81       	ldd	r24, Y+3	; 0x03
 70a:	88 2f       	mov	r24, r24
 70c:	90 e0       	ldi	r25, 0x00	; 0
 70e:	a9 01       	movw	r20, r18
 710:	02 c0       	rjmp	.+4      	; 0x716 <DIO_U8GetPinValue+0x8e>
 712:	55 95       	asr	r21
 714:	47 95       	ror	r20
 716:	8a 95       	dec	r24
 718:	e2 f7       	brpl	.-8      	; 0x712 <DIO_U8GetPinValue+0x8a>
 71a:	ca 01       	movw	r24, r20
 71c:	81 70       	andi	r24, 0x01	; 1
 71e:	89 83       	std	Y+1, r24	; 0x01
 720:	23 c0       	rjmp	.+70     	; 0x768 <DIO_U8GetPinValue+0xe0>
        case 2 : Local_U8Value = GET_BIT(PINC,Copy_U8Pin); break;
 722:	e3 e3       	ldi	r30, 0x33	; 51
 724:	f0 e0       	ldi	r31, 0x00	; 0
 726:	80 81       	ld	r24, Z
 728:	28 2f       	mov	r18, r24
 72a:	30 e0       	ldi	r19, 0x00	; 0
 72c:	8b 81       	ldd	r24, Y+3	; 0x03
 72e:	88 2f       	mov	r24, r24
 730:	90 e0       	ldi	r25, 0x00	; 0
 732:	a9 01       	movw	r20, r18
 734:	02 c0       	rjmp	.+4      	; 0x73a <DIO_U8GetPinValue+0xb2>
 736:	55 95       	asr	r21
 738:	47 95       	ror	r20
 73a:	8a 95       	dec	r24
 73c:	e2 f7       	brpl	.-8      	; 0x736 <DIO_U8GetPinValue+0xae>
 73e:	ca 01       	movw	r24, r20
 740:	81 70       	andi	r24, 0x01	; 1
 742:	89 83       	std	Y+1, r24	; 0x01
 744:	11 c0       	rjmp	.+34     	; 0x768 <DIO_U8GetPinValue+0xe0>
        case 3 : Local_U8Value = GET_BIT(PIND,Copy_U8Pin); break;
 746:	e0 e3       	ldi	r30, 0x30	; 48
 748:	f0 e0       	ldi	r31, 0x00	; 0
 74a:	80 81       	ld	r24, Z
 74c:	28 2f       	mov	r18, r24
 74e:	30 e0       	ldi	r19, 0x00	; 0
 750:	8b 81       	ldd	r24, Y+3	; 0x03
 752:	88 2f       	mov	r24, r24
 754:	90 e0       	ldi	r25, 0x00	; 0
 756:	a9 01       	movw	r20, r18
 758:	02 c0       	rjmp	.+4      	; 0x75e <DIO_U8GetPinValue+0xd6>
 75a:	55 95       	asr	r21
 75c:	47 95       	ror	r20
 75e:	8a 95       	dec	r24
 760:	e2 f7       	brpl	.-8      	; 0x75a <DIO_U8GetPinValue+0xd2>
 762:	ca 01       	movw	r24, r20
 764:	81 70       	andi	r24, 0x01	; 1
 766:	89 83       	std	Y+1, r24	; 0x01
    }
    return Local_U8Value;    
 768:	89 81       	ldd	r24, Y+1	; 0x01
}
 76a:	0f 90       	pop	r0
 76c:	0f 90       	pop	r0
 76e:	0f 90       	pop	r0
 770:	0f 90       	pop	r0
 772:	0f 90       	pop	r0
 774:	cf 91       	pop	r28
 776:	df 91       	pop	r29
 778:	08 95       	ret

0000077a <DIO_U8GetPortValue>:

u8 DIO_U8GetPortValue(u8 Copy_U8Port)
{
 77a:	df 93       	push	r29
 77c:	cf 93       	push	r28
 77e:	00 d0       	rcall	.+0      	; 0x780 <DIO_U8GetPortValue+0x6>
 780:	00 d0       	rcall	.+0      	; 0x782 <DIO_U8GetPortValue+0x8>
 782:	cd b7       	in	r28, 0x3d	; 61
 784:	de b7       	in	r29, 0x3e	; 62
 786:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_U8Value;
	switch(Copy_U8Port)
 788:	8a 81       	ldd	r24, Y+2	; 0x02
 78a:	28 2f       	mov	r18, r24
 78c:	30 e0       	ldi	r19, 0x00	; 0
 78e:	3c 83       	std	Y+4, r19	; 0x04
 790:	2b 83       	std	Y+3, r18	; 0x03
 792:	8b 81       	ldd	r24, Y+3	; 0x03
 794:	9c 81       	ldd	r25, Y+4	; 0x04
 796:	81 30       	cpi	r24, 0x01	; 1
 798:	91 05       	cpc	r25, r1
 79a:	d1 f0       	breq	.+52     	; 0x7d0 <DIO_U8GetPortValue+0x56>
 79c:	2b 81       	ldd	r18, Y+3	; 0x03
 79e:	3c 81       	ldd	r19, Y+4	; 0x04
 7a0:	22 30       	cpi	r18, 0x02	; 2
 7a2:	31 05       	cpc	r19, r1
 7a4:	2c f4       	brge	.+10     	; 0x7b0 <DIO_U8GetPortValue+0x36>
 7a6:	8b 81       	ldd	r24, Y+3	; 0x03
 7a8:	9c 81       	ldd	r25, Y+4	; 0x04
 7aa:	00 97       	sbiw	r24, 0x00	; 0
 7ac:	61 f0       	breq	.+24     	; 0x7c6 <DIO_U8GetPortValue+0x4c>
 7ae:	1e c0       	rjmp	.+60     	; 0x7ec <DIO_U8GetPortValue+0x72>
 7b0:	2b 81       	ldd	r18, Y+3	; 0x03
 7b2:	3c 81       	ldd	r19, Y+4	; 0x04
 7b4:	22 30       	cpi	r18, 0x02	; 2
 7b6:	31 05       	cpc	r19, r1
 7b8:	81 f0       	breq	.+32     	; 0x7da <DIO_U8GetPortValue+0x60>
 7ba:	8b 81       	ldd	r24, Y+3	; 0x03
 7bc:	9c 81       	ldd	r25, Y+4	; 0x04
 7be:	83 30       	cpi	r24, 0x03	; 3
 7c0:	91 05       	cpc	r25, r1
 7c2:	81 f0       	breq	.+32     	; 0x7e4 <DIO_U8GetPortValue+0x6a>
 7c4:	13 c0       	rjmp	.+38     	; 0x7ec <DIO_U8GetPortValue+0x72>
	{
		case 0 : Local_U8Value = PINA; break;
 7c6:	e9 e3       	ldi	r30, 0x39	; 57
 7c8:	f0 e0       	ldi	r31, 0x00	; 0
 7ca:	80 81       	ld	r24, Z
 7cc:	89 83       	std	Y+1, r24	; 0x01
 7ce:	0e c0       	rjmp	.+28     	; 0x7ec <DIO_U8GetPortValue+0x72>
		case 1 : Local_U8Value = PINB; break;
 7d0:	e6 e3       	ldi	r30, 0x36	; 54
 7d2:	f0 e0       	ldi	r31, 0x00	; 0
 7d4:	80 81       	ld	r24, Z
 7d6:	89 83       	std	Y+1, r24	; 0x01
 7d8:	09 c0       	rjmp	.+18     	; 0x7ec <DIO_U8GetPortValue+0x72>
		case 2 : Local_U8Value = PINC; break;
 7da:	e3 e3       	ldi	r30, 0x33	; 51
 7dc:	f0 e0       	ldi	r31, 0x00	; 0
 7de:	80 81       	ld	r24, Z
 7e0:	89 83       	std	Y+1, r24	; 0x01
 7e2:	04 c0       	rjmp	.+8      	; 0x7ec <DIO_U8GetPortValue+0x72>
		case 3 : Local_U8Value = PIND; break;
 7e4:	e0 e3       	ldi	r30, 0x30	; 48
 7e6:	f0 e0       	ldi	r31, 0x00	; 0
 7e8:	80 81       	ld	r24, Z
 7ea:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_U8Value;
 7ec:	89 81       	ldd	r24, Y+1	; 0x01
}
 7ee:	0f 90       	pop	r0
 7f0:	0f 90       	pop	r0
 7f2:	0f 90       	pop	r0
 7f4:	0f 90       	pop	r0
 7f6:	cf 91       	pop	r28
 7f8:	df 91       	pop	r29
 7fa:	08 95       	ret

000007fc <MCP2515_U8ReadRegister>:
#include "SPI_Interface.h"
#include "MCP2515_Interface.h"
#include "MCP2515_Private.h"

u8 MCP2515_U8ReadRegister(u8 address)
{
 7fc:	df 93       	push	r29
 7fe:	cf 93       	push	r28
 800:	00 d0       	rcall	.+0      	; 0x802 <MCP2515_U8ReadRegister+0x6>
 802:	cd b7       	in	r28, 0x3d	; 61
 804:	de b7       	in	r29, 0x3e	; 62
 806:	8a 83       	std	Y+2, r24	; 0x02
	u8 readValue;
	SPI_VidChipSelect(1);
 808:	81 e0       	ldi	r24, 0x01	; 1
 80a:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
	SPI_U8MasterTransmit(INST_READ);
 80e:	83 e0       	ldi	r24, 0x03	; 3
 810:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(address);
 814:	8a 81       	ldd	r24, Y+2	; 0x02
 816:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	readValue = SPI_U8MasterTransmit(0);
 81a:	80 e0       	ldi	r24, 0x00	; 0
 81c:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
 820:	89 83       	std	Y+1, r24	; 0x01
	SPI_VidChipSelect(0);
 822:	80 e0       	ldi	r24, 0x00	; 0
 824:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>

	return readValue;
 828:	89 81       	ldd	r24, Y+1	; 0x01
}
 82a:	0f 90       	pop	r0
 82c:	0f 90       	pop	r0
 82e:	cf 91       	pop	r28
 830:	df 91       	pop	r29
 832:	08 95       	ret

00000834 <MCP2515_VidWriteRegister>:

void MCP2515_VidWriteRegister(u8 address, u8 value)
{
 834:	df 93       	push	r29
 836:	cf 93       	push	r28
 838:	00 d0       	rcall	.+0      	; 0x83a <MCP2515_VidWriteRegister+0x6>
 83a:	cd b7       	in	r28, 0x3d	; 61
 83c:	de b7       	in	r29, 0x3e	; 62
 83e:	89 83       	std	Y+1, r24	; 0x01
 840:	6a 83       	std	Y+2, r22	; 0x02
	SPI_VidChipSelect(1);
 842:	81 e0       	ldi	r24, 0x01	; 1
 844:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
	SPI_U8MasterTransmit(INST_WRITE);
 848:	82 e0       	ldi	r24, 0x02	; 2
 84a:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(address);
 84e:	89 81       	ldd	r24, Y+1	; 0x01
 850:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(value);
 854:	8a 81       	ldd	r24, Y+2	; 0x02
 856:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_VidChipSelect(0);
 85a:	80 e0       	ldi	r24, 0x00	; 0
 85c:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
}
 860:	0f 90       	pop	r0
 862:	0f 90       	pop	r0
 864:	cf 91       	pop	r28
 866:	df 91       	pop	r29
 868:	08 95       	ret

0000086a <MCP2515_VidSetBitTiming>:

void MCP2515_VidSetBitTiming(u8 cnf1Value, u8 cnf2Value, u8 cnf3Value)
{
 86a:	df 93       	push	r29
 86c:	cf 93       	push	r28
 86e:	00 d0       	rcall	.+0      	; 0x870 <MCP2515_VidSetBitTiming+0x6>
 870:	0f 92       	push	r0
 872:	cd b7       	in	r28, 0x3d	; 61
 874:	de b7       	in	r29, 0x3e	; 62
 876:	89 83       	std	Y+1, r24	; 0x01
 878:	6a 83       	std	Y+2, r22	; 0x02
 87a:	4b 83       	std	Y+3, r20	; 0x03
	MCP2515_VidWriteRegister(CNF1, cnf1Value);
 87c:	8a e2       	ldi	r24, 0x2A	; 42
 87e:	69 81       	ldd	r22, Y+1	; 0x01
 880:	0e 94 1a 04 	call	0x834	; 0x834 <MCP2515_VidWriteRegister>
	MCP2515_VidWriteRegister(CNF2, cnf2Value);
 884:	89 e2       	ldi	r24, 0x29	; 41
 886:	6a 81       	ldd	r22, Y+2	; 0x02
 888:	0e 94 1a 04 	call	0x834	; 0x834 <MCP2515_VidWriteRegister>
	MCP2515_VidWriteRegister(CNF3, cnf3Value);
 88c:	88 e2       	ldi	r24, 0x28	; 40
 88e:	6b 81       	ldd	r22, Y+3	; 0x03
 890:	0e 94 1a 04 	call	0x834	; 0x834 <MCP2515_VidWriteRegister>
}
 894:	0f 90       	pop	r0
 896:	0f 90       	pop	r0
 898:	0f 90       	pop	r0
 89a:	cf 91       	pop	r28
 89c:	df 91       	pop	r29
 89e:	08 95       	ret

000008a0 <MCP2515_VidReset>:

void MCP2515_VidReset()
{
 8a0:	df 93       	push	r29
 8a2:	cf 93       	push	r28
 8a4:	cd b7       	in	r28, 0x3d	; 61
 8a6:	de b7       	in	r29, 0x3e	; 62
	SPI_VidChipSelect(1);
 8a8:	81 e0       	ldi	r24, 0x01	; 1
 8aa:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
	SPI_U8MasterTransmit(INST_RESET);
 8ae:	80 ec       	ldi	r24, 0xC0	; 192
 8b0:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_VidChipSelect(0);
 8b4:	80 e0       	ldi	r24, 0x00	; 0
 8b6:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
}
 8ba:	cf 91       	pop	r28
 8bc:	df 91       	pop	r29
 8be:	08 95       	ret

000008c0 <MCP2515_VidChangeBits>:

void MCP2515_VidChangeBits(u8 RegAddress, u8 Mask, u8 Value)
{
 8c0:	df 93       	push	r29
 8c2:	cf 93       	push	r28
 8c4:	00 d0       	rcall	.+0      	; 0x8c6 <MCP2515_VidChangeBits+0x6>
 8c6:	0f 92       	push	r0
 8c8:	cd b7       	in	r28, 0x3d	; 61
 8ca:	de b7       	in	r29, 0x3e	; 62
 8cc:	89 83       	std	Y+1, r24	; 0x01
 8ce:	6a 83       	std	Y+2, r22	; 0x02
 8d0:	4b 83       	std	Y+3, r20	; 0x03
	SPI_VidChipSelect(1);
 8d2:	81 e0       	ldi	r24, 0x01	; 1
 8d4:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
	SPI_U8MasterTransmit(INST_BIT_MODIFY);
 8d8:	85 e0       	ldi	r24, 0x05	; 5
 8da:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(RegAddress);
 8de:	89 81       	ldd	r24, Y+1	; 0x01
 8e0:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(Mask);
 8e4:	8a 81       	ldd	r24, Y+2	; 0x02
 8e6:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(Value);
 8ea:	8b 81       	ldd	r24, Y+3	; 0x03
 8ec:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_VidChipSelect(0);
 8f0:	80 e0       	ldi	r24, 0x00	; 0
 8f2:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
}
 8f6:	0f 90       	pop	r0
 8f8:	0f 90       	pop	r0
 8fa:	0f 90       	pop	r0
 8fc:	cf 91       	pop	r28
 8fe:	df 91       	pop	r29
 900:	08 95       	ret

00000902 <MCP2515_VidSetMode>:

void MCP2515_VidSetMode(u8 mode)
{
 902:	df 93       	push	r29
 904:	cf 93       	push	r28
 906:	0f 92       	push	r0
 908:	cd b7       	in	r28, 0x3d	; 61
 90a:	de b7       	in	r29, 0x3e	; 62
 90c:	89 83       	std	Y+1, r24	; 0x01

	MCP2515_VidChangeBits(CANCTRL, 0xE0, mode << 5);
 90e:	89 81       	ldd	r24, Y+1	; 0x01
 910:	98 2f       	mov	r25, r24
 912:	92 95       	swap	r25
 914:	99 0f       	add	r25, r25
 916:	90 7e       	andi	r25, 0xE0	; 224
 918:	8f e0       	ldi	r24, 0x0F	; 15
 91a:	60 ee       	ldi	r22, 0xE0	; 224
 91c:	49 2f       	mov	r20, r25
 91e:	0e 94 60 04 	call	0x8c0	; 0x8c0 <MCP2515_VidChangeBits>
	while((MCP2515_U8ReadRegister(CANSTAT)>>5) != mode );
 922:	8e e0       	ldi	r24, 0x0E	; 14
 924:	0e 94 fe 03 	call	0x7fc	; 0x7fc <MCP2515_U8ReadRegister>
 928:	98 2f       	mov	r25, r24
 92a:	92 95       	swap	r25
 92c:	96 95       	lsr	r25
 92e:	97 70       	andi	r25, 0x07	; 7
 930:	89 81       	ldd	r24, Y+1	; 0x01
 932:	98 17       	cp	r25, r24
 934:	b1 f7       	brne	.-20     	; 0x922 <MCP2515_VidSetMode+0x20>
}
 936:	0f 90       	pop	r0
 938:	cf 91       	pop	r28
 93a:	df 91       	pop	r29
 93c:	08 95       	ret

0000093e <MCP2515_VidSetRollover>:

void MCP2515_VidSetRollover(u8 value)
{
 93e:	df 93       	push	r29
 940:	cf 93       	push	r28
 942:	0f 92       	push	r0
 944:	cd b7       	in	r28, 0x3d	; 61
 946:	de b7       	in	r29, 0x3e	; 62
 948:	89 83       	std	Y+1, r24	; 0x01
	MCP2515_VidChangeBits(RXB0CTRL, 1<<BUKT, value<<BUKT);
 94a:	89 81       	ldd	r24, Y+1	; 0x01
 94c:	98 2f       	mov	r25, r24
 94e:	99 0f       	add	r25, r25
 950:	99 0f       	add	r25, r25
 952:	80 e6       	ldi	r24, 0x60	; 96
 954:	64 e0       	ldi	r22, 0x04	; 4
 956:	49 2f       	mov	r20, r25
 958:	0e 94 60 04 	call	0x8c0	; 0x8c0 <MCP2515_VidChangeBits>
}
 95c:	0f 90       	pop	r0
 95e:	cf 91       	pop	r28
 960:	df 91       	pop	r29
 962:	08 95       	ret

00000964 <MCP2515_VidSetMask>:

void MCP2515_VidSetMask(u8 maskAddress, u32 maskValue, u8 extended)
{
 964:	df 93       	push	r29
 966:	cf 93       	push	r28
 968:	00 d0       	rcall	.+0      	; 0x96a <MCP2515_VidSetMask+0x6>
 96a:	00 d0       	rcall	.+0      	; 0x96c <MCP2515_VidSetMask+0x8>
 96c:	00 d0       	rcall	.+0      	; 0x96e <MCP2515_VidSetMask+0xa>
 96e:	cd b7       	in	r28, 0x3d	; 61
 970:	de b7       	in	r29, 0x3e	; 62
 972:	89 83       	std	Y+1, r24	; 0x01
 974:	4a 83       	std	Y+2, r20	; 0x02
 976:	5b 83       	std	Y+3, r21	; 0x03
 978:	6c 83       	std	Y+4, r22	; 0x04
 97a:	7d 83       	std	Y+5, r23	; 0x05
 97c:	2e 83       	std	Y+6, r18	; 0x06
	SPI_VidChipSelect(1);
 97e:	81 e0       	ldi	r24, 0x01	; 1
 980:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
	SPI_U8MasterTransmit(INST_WRITE);
 984:	82 e0       	ldi	r24, 0x02	; 2
 986:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(maskAddress);
 98a:	89 81       	ldd	r24, Y+1	; 0x01
 98c:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>

	if(extended)
 990:	8e 81       	ldd	r24, Y+6	; 0x06
 992:	88 23       	and	r24, r24
 994:	09 f4       	brne	.+2      	; 0x998 <MCP2515_VidSetMask+0x34>
 996:	43 c0       	rjmp	.+134    	; 0xa1e <MCP2515_VidSetMask+0xba>
	{
		// extended address
		SPI_U8MasterTransmit((u8) (maskValue >> 3));
 998:	8a 81       	ldd	r24, Y+2	; 0x02
 99a:	9b 81       	ldd	r25, Y+3	; 0x03
 99c:	ac 81       	ldd	r26, Y+4	; 0x04
 99e:	bd 81       	ldd	r27, Y+5	; 0x05
 9a0:	68 94       	set
 9a2:	12 f8       	bld	r1, 2
 9a4:	b6 95       	lsr	r27
 9a6:	a7 95       	ror	r26
 9a8:	97 95       	ror	r25
 9aa:	87 95       	ror	r24
 9ac:	16 94       	lsr	r1
 9ae:	d1 f7       	brne	.-12     	; 0x9a4 <MCP2515_VidSetMask+0x40>
 9b0:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
		SPI_U8MasterTransmit((u8) (maskValue << 5) | (1<<3) | (u8) (maskValue >> 27));
 9b4:	8a 81       	ldd	r24, Y+2	; 0x02
 9b6:	28 2f       	mov	r18, r24
 9b8:	22 95       	swap	r18
 9ba:	22 0f       	add	r18, r18
 9bc:	20 7e       	andi	r18, 0xE0	; 224
 9be:	8a 81       	ldd	r24, Y+2	; 0x02
 9c0:	9b 81       	ldd	r25, Y+3	; 0x03
 9c2:	ac 81       	ldd	r26, Y+4	; 0x04
 9c4:	bd 81       	ldd	r27, Y+5	; 0x05
 9c6:	07 2e       	mov	r0, r23
 9c8:	7b e1       	ldi	r23, 0x1B	; 27
 9ca:	b6 95       	lsr	r27
 9cc:	a7 95       	ror	r26
 9ce:	97 95       	ror	r25
 9d0:	87 95       	ror	r24
 9d2:	7a 95       	dec	r23
 9d4:	d1 f7       	brne	.-12     	; 0x9ca <MCP2515_VidSetMask+0x66>
 9d6:	70 2d       	mov	r23, r0
 9d8:	82 2b       	or	r24, r18
 9da:	88 60       	ori	r24, 0x08	; 8
 9dc:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
		SPI_U8MasterTransmit((u8) (maskValue >> 19));
 9e0:	8a 81       	ldd	r24, Y+2	; 0x02
 9e2:	9b 81       	ldd	r25, Y+3	; 0x03
 9e4:	ac 81       	ldd	r26, Y+4	; 0x04
 9e6:	bd 81       	ldd	r27, Y+5	; 0x05
 9e8:	07 2e       	mov	r0, r23
 9ea:	73 e1       	ldi	r23, 0x13	; 19
 9ec:	b6 95       	lsr	r27
 9ee:	a7 95       	ror	r26
 9f0:	97 95       	ror	r25
 9f2:	87 95       	ror	r24
 9f4:	7a 95       	dec	r23
 9f6:	d1 f7       	brne	.-12     	; 0x9ec <MCP2515_VidSetMask+0x88>
 9f8:	70 2d       	mov	r23, r0
 9fa:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
		SPI_U8MasterTransmit((u8) (maskValue >> 11));
 9fe:	8a 81       	ldd	r24, Y+2	; 0x02
 a00:	9b 81       	ldd	r25, Y+3	; 0x03
 a02:	ac 81       	ldd	r26, Y+4	; 0x04
 a04:	bd 81       	ldd	r27, Y+5	; 0x05
 a06:	07 2e       	mov	r0, r23
 a08:	7b e0       	ldi	r23, 0x0B	; 11
 a0a:	b6 95       	lsr	r27
 a0c:	a7 95       	ror	r26
 a0e:	97 95       	ror	r25
 a10:	87 95       	ror	r24
 a12:	7a 95       	dec	r23
 a14:	d1 f7       	brne	.-12     	; 0xa0a <MCP2515_VidSetMask+0xa6>
 a16:	70 2d       	mov	r23, r0
 a18:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
 a1c:	14 c0       	rjmp	.+40     	; 0xa46 <MCP2515_VidSetMask+0xe2>
	}
	else
	{
		// standard address
		SPI_U8MasterTransmit((u8) (maskValue >> 3));
 a1e:	8a 81       	ldd	r24, Y+2	; 0x02
 a20:	9b 81       	ldd	r25, Y+3	; 0x03
 a22:	ac 81       	ldd	r26, Y+4	; 0x04
 a24:	bd 81       	ldd	r27, Y+5	; 0x05
 a26:	68 94       	set
 a28:	12 f8       	bld	r1, 2
 a2a:	b6 95       	lsr	r27
 a2c:	a7 95       	ror	r26
 a2e:	97 95       	ror	r25
 a30:	87 95       	ror	r24
 a32:	16 94       	lsr	r1
 a34:	d1 f7       	brne	.-12     	; 0xa2a <MCP2515_VidSetMask+0xc6>
 a36:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
		SPI_U8MasterTransmit((u8) (maskValue << 5));
 a3a:	8a 81       	ldd	r24, Y+2	; 0x02
 a3c:	82 95       	swap	r24
 a3e:	88 0f       	add	r24, r24
 a40:	80 7e       	andi	r24, 0xE0	; 224
 a42:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	}
	SPI_VidChipSelect(0);
 a46:	80 e0       	ldi	r24, 0x00	; 0
 a48:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>
}
 a4c:	26 96       	adiw	r28, 0x06	; 6
 a4e:	0f b6       	in	r0, 0x3f	; 63
 a50:	f8 94       	cli
 a52:	de bf       	out	0x3e, r29	; 62
 a54:	0f be       	out	0x3f, r0	; 63
 a56:	cd bf       	out	0x3d, r28	; 61
 a58:	cf 91       	pop	r28
 a5a:	df 91       	pop	r29
 a5c:	08 95       	ret

00000a5e <MCP2515_VidReceiveInit>:

void MCP2515_VidReceiveInit(void)
{
 a5e:	df 93       	push	r29
 a60:	cf 93       	push	r28
 a62:	cd b7       	in	r28, 0x3d	; 61
 a64:	de b7       	in	r29, 0x3e	; 62
	SPI_VidMasterInit();
 a66:	0e 94 94 05 	call	0xb28	; 0xb28 <SPI_VidMasterInit>
	MCP2515_VidReset();
 a6a:	0e 94 50 04 	call	0x8a0	; 0x8a0 <MCP2515_VidReset>

//	// enter configuration mode and enable CLKOUT with no prescaler
	MCP2515_VidWriteRegister(CANCTRL, 0x84);
 a6e:	8f e0       	ldi	r24, 0x0F	; 15
 a70:	64 e8       	ldi	r22, 0x84	; 132
 a72:	0e 94 1a 04 	call	0x834	; 0x834 <MCP2515_VidWriteRegister>
	while((MCP2515_U8ReadRegister(CANSTAT)>>5) != MCP2515_MODE_CONFG);
 a76:	8e e0       	ldi	r24, 0x0E	; 14
 a78:	0e 94 fe 03 	call	0x7fc	; 0x7fc <MCP2515_U8ReadRegister>
 a7c:	82 95       	swap	r24
 a7e:	86 95       	lsr	r24
 a80:	87 70       	andi	r24, 0x07	; 7
 a82:	84 30       	cpi	r24, 0x04	; 4
 a84:	c1 f7       	brne	.-16     	; 0xa76 <MCP2515_VidReceiveInit+0x18>
//	// to run at 250KHz bitrate using 8MHz osc
	MCP2515_VidSetBitTiming((2<<6), (1<<7)|(6<<3)|(1), (5));
 a86:	80 e8       	ldi	r24, 0x80	; 128
 a88:	61 eb       	ldi	r22, 0xB1	; 177
 a8a:	45 e0       	ldi	r20, 0x05	; 5
 a8c:	0e 94 35 04 	call	0x86a	; 0x86a <MCP2515_VidSetBitTiming>
//	MCP2515_VidSetBitTiming(0, 0xAC, 0x03);
	// accept all messages
	MCP2515_VidSetMask(RXM0SIDH, 0x00000000, 1);
 a90:	80 e2       	ldi	r24, 0x20	; 32
 a92:	40 e0       	ldi	r20, 0x00	; 0
 a94:	50 e0       	ldi	r21, 0x00	; 0
 a96:	60 e0       	ldi	r22, 0x00	; 0
 a98:	70 e0       	ldi	r23, 0x00	; 0
 a9a:	21 e0       	ldi	r18, 0x01	; 1
 a9c:	0e 94 b2 04 	call	0x964	; 0x964 <MCP2515_VidSetMask>
	MCP2515_VidSetMask(RXM1SIDH, 0x00000000, 1);
 aa0:	84 e2       	ldi	r24, 0x24	; 36
 aa2:	40 e0       	ldi	r20, 0x00	; 0
 aa4:	50 e0       	ldi	r21, 0x00	; 0
 aa6:	60 e0       	ldi	r22, 0x00	; 0
 aa8:	70 e0       	ldi	r23, 0x00	; 0
 aaa:	21 e0       	ldi	r18, 0x01	; 1
 aac:	0e 94 b2 04 	call	0x964	; 0x964 <MCP2515_VidSetMask>
	MCP2515_VidSetRollover(1);
 ab0:	81 e0       	ldi	r24, 0x01	; 1
 ab2:	0e 94 9f 04 	call	0x93e	; 0x93e <MCP2515_VidSetRollover>

	MCP2515_VidWriteRegister(CANINTE, 1<<RX0IE);
 ab6:	8b e2       	ldi	r24, 0x2B	; 43
 ab8:	61 e0       	ldi	r22, 0x01	; 1
 aba:	0e 94 1a 04 	call	0x834	; 0x834 <MCP2515_VidWriteRegister>

	MCP2515_VidSetMode(MCP2515_MODE_NORMAL);
 abe:	80 e0       	ldi	r24, 0x00	; 0
 ac0:	0e 94 81 04 	call	0x902	; 0x902 <MCP2515_VidSetMode>
}
 ac4:	cf 91       	pop	r28
 ac6:	df 91       	pop	r29
 ac8:	08 95       	ret

00000aca <MCP2515_VidReceiveCANmsg>:

u8 readBuffer[14];
void MCP2515_VidReceiveCANmsg(void)
{
 aca:	0f 93       	push	r16
 acc:	1f 93       	push	r17
 ace:	df 93       	push	r29
 ad0:	cf 93       	push	r28
 ad2:	0f 92       	push	r0
 ad4:	cd b7       	in	r28, 0x3d	; 61
 ad6:	de b7       	in	r29, 0x3e	; 62
	SPI_VidChipSelect(1);
 ad8:	81 e0       	ldi	r24, 0x01	; 1
 ada:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>

	SPI_U8MasterTransmit(INST_READ);
 ade:	83 e0       	ldi	r24, 0x03	; 3
 ae0:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
	SPI_U8MasterTransmit(RXB0CTRL);
 ae4:	80 e6       	ldi	r24, 0x60	; 96
 ae6:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>

	for(u8 i=0; i<14; i++)
 aea:	19 82       	std	Y+1, r1	; 0x01
 aec:	0d c0       	rjmp	.+26     	; 0xb08 <MCP2515_VidReceiveCANmsg+0x3e>
	{
		readBuffer[i] = SPI_U8MasterTransmit(0);
 aee:	89 81       	ldd	r24, Y+1	; 0x01
 af0:	08 2f       	mov	r16, r24
 af2:	10 e0       	ldi	r17, 0x00	; 0
 af4:	80 e0       	ldi	r24, 0x00	; 0
 af6:	0e 94 2b 06 	call	0xc56	; 0xc56 <SPI_U8MasterTransmit>
 afa:	f8 01       	movw	r30, r16
 afc:	e0 5a       	subi	r30, 0xA0	; 160
 afe:	ff 4f       	sbci	r31, 0xFF	; 255
 b00:	80 83       	st	Z, r24
	SPI_VidChipSelect(1);

	SPI_U8MasterTransmit(INST_READ);
	SPI_U8MasterTransmit(RXB0CTRL);

	for(u8 i=0; i<14; i++)
 b02:	89 81       	ldd	r24, Y+1	; 0x01
 b04:	8f 5f       	subi	r24, 0xFF	; 255
 b06:	89 83       	std	Y+1, r24	; 0x01
 b08:	89 81       	ldd	r24, Y+1	; 0x01
 b0a:	8e 30       	cpi	r24, 0x0E	; 14
 b0c:	80 f3       	brcs	.-32     	; 0xaee <MCP2515_VidReceiveCANmsg+0x24>
	{
		readBuffer[i] = SPI_U8MasterTransmit(0);
	}

	SPI_VidChipSelect(0);
 b0e:	80 e0       	ldi	r24, 0x00	; 0
 b10:	0e 94 13 06 	call	0xc26	; 0xc26 <SPI_VidChipSelect>

	MCP2515_VidWriteRegister(CANINTF, 0);
 b14:	8c e2       	ldi	r24, 0x2C	; 44
 b16:	60 e0       	ldi	r22, 0x00	; 0
 b18:	0e 94 1a 04 	call	0x834	; 0x834 <MCP2515_VidWriteRegister>
 b1c:	0f 90       	pop	r0
 b1e:	cf 91       	pop	r28
 b20:	df 91       	pop	r29
 b22:	1f 91       	pop	r17
 b24:	0f 91       	pop	r16
 b26:	08 95       	ret

00000b28 <SPI_VidMasterInit>:
#include "BIT_MATH.h"
#include "SPI_Registers.h"
#include "DIO_Interface.h"

void SPI_VidMasterInit(void)
{
 b28:	df 93       	push	r29
 b2a:	cf 93       	push	r28
 b2c:	0f 92       	push	r0
 b2e:	cd b7       	in	r28, 0x3d	; 61
 b30:	de b7       	in	r29, 0x3e	; 62
	u8 temp_SPCR = 0;
 b32:	19 82       	std	Y+1, r1	; 0x01

	// Set MOSI pin direction output
	DIO_VidSetPinDirection(DIO_PORTB, DIO_PIN5, DIO_OUTPUT);
 b34:	81 e0       	ldi	r24, 0x01	; 1
 b36:	65 e0       	ldi	r22, 0x05	; 5
 b38:	41 e0       	ldi	r20, 0x01	; 1
 b3a:	0e 94 86 00 	call	0x10c	; 0x10c <DIO_VidSetPinDirection>
	// Set MISO pin direction input with pull-up resistance (Not necessary)
	DIO_VidSetPinDirection(DIO_PORTB, DIO_PIN6, DIO_INPUT);
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	66 e0       	ldi	r22, 0x06	; 6
 b42:	40 e0       	ldi	r20, 0x00	; 0
 b44:	0e 94 86 00 	call	0x10c	; 0x10c <DIO_VidSetPinDirection>
	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN6, DIO_HIGH);
 b48:	81 e0       	ldi	r24, 0x01	; 1
 b4a:	66 e0       	ldi	r22, 0x06	; 6
 b4c:	41 e0       	ldi	r20, 0x01	; 1
 b4e:	0e 94 c7 01 	call	0x38e	; 0x38e <DIO_VidSetPinValue>
	// Set clock pin direction output with
	DIO_VidSetPinDirection(DIO_PORTB, DIO_PIN7, DIO_OUTPUT);
 b52:	81 e0       	ldi	r24, 0x01	; 1
 b54:	67 e0       	ldi	r22, 0x07	; 7
 b56:	41 e0       	ldi	r20, 0x01	; 1
 b58:	0e 94 86 00 	call	0x10c	; 0x10c <DIO_VidSetPinDirection>
//	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN7, DIO_LOW);

	// enable SPI
	SET_BIT(temp_SPCR, 6);
 b5c:	89 81       	ldd	r24, Y+1	; 0x01
 b5e:	80 64       	ori	r24, 0x40	; 64
 b60:	89 83       	std	Y+1, r24	; 0x01

	// data order >>>> transmit MSB first
	CLR_BIT(temp_SPCR, 5);
 b62:	89 81       	ldd	r24, Y+1	; 0x01
 b64:	8f 7d       	andi	r24, 0xDF	; 223
 b66:	89 83       	std	Y+1, r24	; 0x01

	// configure SS pin as output and choose master spi mode
	DIO_VidSetPinDirection(DIO_PORTB, DIO_PIN4, DIO_OUTPUT);
 b68:	81 e0       	ldi	r24, 0x01	; 1
 b6a:	64 e0       	ldi	r22, 0x04	; 4
 b6c:	41 e0       	ldi	r20, 0x01	; 1
 b6e:	0e 94 86 00 	call	0x10c	; 0x10c <DIO_VidSetPinDirection>
	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_HIGH);
 b72:	81 e0       	ldi	r24, 0x01	; 1
 b74:	64 e0       	ldi	r22, 0x04	; 4
 b76:	41 e0       	ldi	r20, 0x01	; 1
 b78:	0e 94 c7 01 	call	0x38e	; 0x38e <DIO_VidSetPinValue>
	SET_BIT(temp_SPCR, 4);
 b7c:	89 81       	ldd	r24, Y+1	; 0x01
 b7e:	80 61       	ori	r24, 0x10	; 16
 b80:	89 83       	std	Y+1, r24	; 0x01



	// clock polarity >>> leading rising edge
	CLR_BIT(temp_SPCR, 3);
 b82:	89 81       	ldd	r24, Y+1	; 0x01
 b84:	87 7f       	andi	r24, 0xF7	; 247
 b86:	89 83       	std	Y+1, r24	; 0x01

	// clock phase >>>> sampling at rising edge
	CLR_BIT(temp_SPCR, 2);
 b88:	89 81       	ldd	r24, Y+1	; 0x01
 b8a:	8b 7f       	andi	r24, 0xFB	; 251
 b8c:	89 83       	std	Y+1, r24	; 0x01

	// clock oscillator >> F_CPU / 4
	CLR_BIT(temp_SPCR, 1);
 b8e:	89 81       	ldd	r24, Y+1	; 0x01
 b90:	8d 7f       	andi	r24, 0xFD	; 253
 b92:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(temp_SPCR, 0);
 b94:	89 81       	ldd	r24, Y+1	; 0x01
 b96:	8e 7f       	andi	r24, 0xFE	; 254
 b98:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(SPSR, 0);
 b9a:	ae e2       	ldi	r26, 0x2E	; 46
 b9c:	b0 e0       	ldi	r27, 0x00	; 0
 b9e:	ee e2       	ldi	r30, 0x2E	; 46
 ba0:	f0 e0       	ldi	r31, 0x00	; 0
 ba2:	80 81       	ld	r24, Z
 ba4:	8e 7f       	andi	r24, 0xFE	; 254
 ba6:	8c 93       	st	X, r24

	// enable interrupt
//	SET_BIT(temp_SPCR, 7);

	SPCR = temp_SPCR;
 ba8:	ed e2       	ldi	r30, 0x2D	; 45
 baa:	f0 e0       	ldi	r31, 0x00	; 0
 bac:	89 81       	ldd	r24, Y+1	; 0x01
 bae:	80 83       	st	Z, r24
}
 bb0:	0f 90       	pop	r0
 bb2:	cf 91       	pop	r28
 bb4:	df 91       	pop	r29
 bb6:	08 95       	ret

00000bb8 <SPI_VidSlaveInit>:

void SPI_VidSlaveInit(void)
{
 bb8:	df 93       	push	r29
 bba:	cf 93       	push	r28
 bbc:	0f 92       	push	r0
 bbe:	cd b7       	in	r28, 0x3d	; 61
 bc0:	de b7       	in	r29, 0x3e	; 62
	u8 temp_SPCR=0;
 bc2:	19 82       	std	Y+1, r1	; 0x01
	// enable SPI
	SET_BIT(temp_SPCR, 6);
 bc4:	89 81       	ldd	r24, Y+1	; 0x01
 bc6:	80 64       	ori	r24, 0x40	; 64
 bc8:	89 83       	std	Y+1, r24	; 0x01

	// data order >>>> transmit LSB first
	SET_BIT(temp_SPCR, 5);
 bca:	89 81       	ldd	r24, Y+1	; 0x01
 bcc:	80 62       	ori	r24, 0x20	; 32
 bce:	89 83       	std	Y+1, r24	; 0x01

	// configure SS pin as output and choose master spi mode
	DIO_VidSetPinDirection(DIO_PORTB, DIO_PIN4, DIO_INPUT);
 bd0:	81 e0       	ldi	r24, 0x01	; 1
 bd2:	64 e0       	ldi	r22, 0x04	; 4
 bd4:	40 e0       	ldi	r20, 0x00	; 0
 bd6:	0e 94 86 00 	call	0x10c	; 0x10c <DIO_VidSetPinDirection>
	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_HIGH);
 bda:	81 e0       	ldi	r24, 0x01	; 1
 bdc:	64 e0       	ldi	r22, 0x04	; 4
 bde:	41 e0       	ldi	r20, 0x01	; 1
 be0:	0e 94 c7 01 	call	0x38e	; 0x38e <DIO_VidSetPinValue>
	CLR_BIT(temp_SPCR, 4);
 be4:	89 81       	ldd	r24, Y+1	; 0x01
 be6:	8f 7e       	andi	r24, 0xEF	; 239
 be8:	89 83       	std	Y+1, r24	; 0x01



	// clock polarity >>> leading rising edge
	CLR_BIT(temp_SPCR, 3);
 bea:	89 81       	ldd	r24, Y+1	; 0x01
 bec:	87 7f       	andi	r24, 0xF7	; 247
 bee:	89 83       	std	Y+1, r24	; 0x01

	// clock phase >>>> setup at leading then sample at trailing
	SET_BIT(temp_SPCR, 2);
 bf0:	89 81       	ldd	r24, Y+1	; 0x01
 bf2:	84 60       	ori	r24, 0x04	; 4
 bf4:	89 83       	std	Y+1, r24	; 0x01

	// clock oscillator >> F_CPU / 4
	CLR_BIT(temp_SPCR, 1);
 bf6:	89 81       	ldd	r24, Y+1	; 0x01
 bf8:	8d 7f       	andi	r24, 0xFD	; 253
 bfa:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(temp_SPCR, 0);
 bfc:	89 81       	ldd	r24, Y+1	; 0x01
 bfe:	8e 7f       	andi	r24, 0xFE	; 254
 c00:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(SPSR, 0);
 c02:	ae e2       	ldi	r26, 0x2E	; 46
 c04:	b0 e0       	ldi	r27, 0x00	; 0
 c06:	ee e2       	ldi	r30, 0x2E	; 46
 c08:	f0 e0       	ldi	r31, 0x00	; 0
 c0a:	80 81       	ld	r24, Z
 c0c:	8e 7f       	andi	r24, 0xFE	; 254
 c0e:	8c 93       	st	X, r24

	// enable interrupt
	SET_BIT(temp_SPCR, 7);
 c10:	89 81       	ldd	r24, Y+1	; 0x01
 c12:	80 68       	ori	r24, 0x80	; 128
 c14:	89 83       	std	Y+1, r24	; 0x01

	SPCR = temp_SPCR;
 c16:	ed e2       	ldi	r30, 0x2D	; 45
 c18:	f0 e0       	ldi	r31, 0x00	; 0
 c1a:	89 81       	ldd	r24, Y+1	; 0x01
 c1c:	80 83       	st	Z, r24
}
 c1e:	0f 90       	pop	r0
 c20:	cf 91       	pop	r28
 c22:	df 91       	pop	r29
 c24:	08 95       	ret

00000c26 <SPI_VidChipSelect>:

void SPI_VidChipSelect(u8 state)
{
 c26:	df 93       	push	r29
 c28:	cf 93       	push	r28
 c2a:	0f 92       	push	r0
 c2c:	cd b7       	in	r28, 0x3d	; 61
 c2e:	de b7       	in	r29, 0x3e	; 62
 c30:	89 83       	std	Y+1, r24	; 0x01
	if(state == 1)
 c32:	89 81       	ldd	r24, Y+1	; 0x01
 c34:	81 30       	cpi	r24, 0x01	; 1
 c36:	31 f4       	brne	.+12     	; 0xc44 <SPI_VidChipSelect+0x1e>
	{
		DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_LOW);
 c38:	81 e0       	ldi	r24, 0x01	; 1
 c3a:	64 e0       	ldi	r22, 0x04	; 4
 c3c:	40 e0       	ldi	r20, 0x00	; 0
 c3e:	0e 94 c7 01 	call	0x38e	; 0x38e <DIO_VidSetPinValue>
 c42:	05 c0       	rjmp	.+10     	; 0xc4e <SPI_VidChipSelect+0x28>
	}
	else
	{
		DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_HIGH);
 c44:	81 e0       	ldi	r24, 0x01	; 1
 c46:	64 e0       	ldi	r22, 0x04	; 4
 c48:	41 e0       	ldi	r20, 0x01	; 1
 c4a:	0e 94 c7 01 	call	0x38e	; 0x38e <DIO_VidSetPinValue>
	}
}
 c4e:	0f 90       	pop	r0
 c50:	cf 91       	pop	r28
 c52:	df 91       	pop	r29
 c54:	08 95       	ret

00000c56 <SPI_U8MasterTransmit>:


u8 SPI_U8MasterTransmit(u8 Local_U8Data)
{
 c56:	df 93       	push	r29
 c58:	cf 93       	push	r28
 c5a:	00 d0       	rcall	.+0      	; 0xc5c <SPI_U8MasterTransmit+0x6>
 c5c:	cd b7       	in	r28, 0x3d	; 61
 c5e:	de b7       	in	r29, 0x3e	; 62
 c60:	8a 83       	std	Y+2, r24	; 0x02
	u8 dataRead=0;
 c62:	19 82       	std	Y+1, r1	; 0x01
	// slave select low (activate the slave)
//	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_LOW);
//	SPI_VidChipSelect(1);
	SPDR = Local_U8Data;
 c64:	ef e2       	ldi	r30, 0x2F	; 47
 c66:	f0 e0       	ldi	r31, 0x00	; 0
 c68:	8a 81       	ldd	r24, Y+2	; 0x02
 c6a:	80 83       	st	Z, r24
	while(GET_BIT(SPSR, 7)==0);
 c6c:	ee e2       	ldi	r30, 0x2E	; 46
 c6e:	f0 e0       	ldi	r31, 0x00	; 0
 c70:	80 81       	ld	r24, Z
 c72:	88 23       	and	r24, r24
 c74:	dc f7       	brge	.-10     	; 0xc6c <SPI_U8MasterTransmit+0x16>
	dataRead = SPDR;
 c76:	ef e2       	ldi	r30, 0x2F	; 47
 c78:	f0 e0       	ldi	r31, 0x00	; 0
 c7a:	80 81       	ld	r24, Z
 c7c:	89 83       	std	Y+1, r24	; 0x01
	// slave select high (deactivate the slave)
//	DIO_VidSetPinValue(DIO_PORTB, DIO_PIN4, DIO_HIGH);
//	SPI_VidChipSelect(0);
	return dataRead;
 c7e:	89 81       	ldd	r24, Y+1	; 0x01
}
 c80:	0f 90       	pop	r0
 c82:	0f 90       	pop	r0
 c84:	cf 91       	pop	r28
 c86:	df 91       	pop	r29
 c88:	08 95       	ret

00000c8a <UART_VidInit>:
#include "BIT_MATH.h"
#include "UART_Registers.h"
#include "UART_Config.h"

void UART_VidInit(void)
{
 c8a:	df 93       	push	r29
 c8c:	cf 93       	push	r28
 c8e:	00 d0       	rcall	.+0      	; 0xc90 <UART_VidInit+0x6>
 c90:	cd b7       	in	r28, 0x3d	; 61
 c92:	de b7       	in	r29, 0x3e	; 62
	u8 temp_UCSRC= 0b10000000;
 c94:	80 e8       	ldi	r24, 0x80	; 128
 c96:	8a 83       	std	Y+2, r24	; 0x02
	u8 temp_UBRRH= 0b00000000;
 c98:	19 82       	std	Y+1, r1	; 0x01
	// interrupt enable
//	SET_BIT(UCSRB, 7);

	// Receiver enable
	SET_BIT(UCSRB, 4);
 c9a:	aa e2       	ldi	r26, 0x2A	; 42
 c9c:	b0 e0       	ldi	r27, 0x00	; 0
 c9e:	ea e2       	ldi	r30, 0x2A	; 42
 ca0:	f0 e0       	ldi	r31, 0x00	; 0
 ca2:	80 81       	ld	r24, Z
 ca4:	80 61       	ori	r24, 0x10	; 16
 ca6:	8c 93       	st	X, r24

	// Transmitter enable
	SET_BIT(UCSRB, 3);
 ca8:	aa e2       	ldi	r26, 0x2A	; 42
 caa:	b0 e0       	ldi	r27, 0x00	; 0
 cac:	ea e2       	ldi	r30, 0x2A	; 42
 cae:	f0 e0       	ldi	r31, 0x00	; 0
 cb0:	80 81       	ld	r24, Z
 cb2:	88 60       	ori	r24, 0x08	; 8
 cb4:	8c 93       	st	X, r24

	// choose the data size
	// data size = 8 bits
	CLR_BIT(UCSRB, 2);
 cb6:	aa e2       	ldi	r26, 0x2A	; 42
 cb8:	b0 e0       	ldi	r27, 0x00	; 0
 cba:	ea e2       	ldi	r30, 0x2A	; 42
 cbc:	f0 e0       	ldi	r31, 0x00	; 0
 cbe:	80 81       	ld	r24, Z
 cc0:	8b 7f       	andi	r24, 0xFB	; 251
 cc2:	8c 93       	st	X, r24
	SET_BIT(temp_UCSRC, 2);
 cc4:	8a 81       	ldd	r24, Y+2	; 0x02
 cc6:	84 60       	ori	r24, 0x04	; 4
 cc8:	8a 83       	std	Y+2, r24	; 0x02
	SET_BIT(temp_UCSRC, 1);
 cca:	8a 81       	ldd	r24, Y+2	; 0x02
 ccc:	82 60       	ori	r24, 0x02	; 2
 cce:	8a 83       	std	Y+2, r24	; 0x02

	// set UART mode as Asynchronous
	CLR_BIT(temp_UCSRC, 6);
 cd0:	8a 81       	ldd	r24, Y+2	; 0x02
 cd2:	8f 7b       	andi	r24, 0xBF	; 191
 cd4:	8a 83       	std	Y+2, r24	; 0x02

	// parity mode >>> disabled
	CLR_BIT(temp_UCSRC, 5);
 cd6:	8a 81       	ldd	r24, Y+2	; 0x02
 cd8:	8f 7d       	andi	r24, 0xDF	; 223
 cda:	8a 83       	std	Y+2, r24	; 0x02
	CLR_BIT(temp_UCSRC, 4);
 cdc:	8a 81       	ldd	r24, Y+2	; 0x02
 cde:	8f 7e       	andi	r24, 0xEF	; 239
 ce0:	8a 83       	std	Y+2, r24	; 0x02

	// stop bit >>> 1-bit
	CLR_BIT(temp_UCSRC, 3);
 ce2:	8a 81       	ldd	r24, Y+2	; 0x02
 ce4:	87 7f       	andi	r24, 0xF7	; 247
 ce6:	8a 83       	std	Y+2, r24	; 0x02
	// their I/O registers to 64 place in the memory only
	// >> the reason for only 64 place is that the argument
	// of the IN / OUT assembly instructions takes 6-bit value
	// >> also with this register can't do read-modify-write
	// operation , as it has special way to read it
	UCSRC = temp_UCSRC;
 ce8:	e0 e4       	ldi	r30, 0x40	; 64
 cea:	f0 e0       	ldi	r31, 0x00	; 0
 cec:	8a 81       	ldd	r24, Y+2	; 0x02
 cee:	80 83       	st	Z, r24

	// set baud rate to 9600 while F_CBU = 8MHz >>> 51
	UBRRL = 51; // 12 >>> 38400
 cf0:	e9 e2       	ldi	r30, 0x29	; 41
 cf2:	f0 e0       	ldi	r31, 0x00	; 0
 cf4:	83 e3       	ldi	r24, 0x33	; 51
 cf6:	80 83       	st	Z, r24
}
 cf8:	0f 90       	pop	r0
 cfa:	0f 90       	pop	r0
 cfc:	cf 91       	pop	r28
 cfe:	df 91       	pop	r29
 d00:	08 95       	ret

00000d02 <UART_VidSendData>:

void UART_VidSendData(u8 Copy_U8Data)
{
 d02:	df 93       	push	r29
 d04:	cf 93       	push	r28
 d06:	0f 92       	push	r0
 d08:	cd b7       	in	r28, 0x3d	; 61
 d0a:	de b7       	in	r29, 0x3e	; 62
 d0c:	89 83       	std	Y+1, r24	; 0x01
	// loop till Data register empty flag is 1 >>> empty
	while(GET_BIT(UCSRA, 5)==0);
 d0e:	eb e2       	ldi	r30, 0x2B	; 43
 d10:	f0 e0       	ldi	r31, 0x00	; 0
 d12:	80 81       	ld	r24, Z
 d14:	82 95       	swap	r24
 d16:	86 95       	lsr	r24
 d18:	87 70       	andi	r24, 0x07	; 7
 d1a:	88 2f       	mov	r24, r24
 d1c:	90 e0       	ldi	r25, 0x00	; 0
 d1e:	81 70       	andi	r24, 0x01	; 1
 d20:	90 70       	andi	r25, 0x00	; 0
 d22:	00 97       	sbiw	r24, 0x00	; 0
 d24:	a1 f3       	breq	.-24     	; 0xd0e <UART_VidSendData+0xc>

	// write the data
	UDR = Copy_U8Data;
 d26:	ec e2       	ldi	r30, 0x2C	; 44
 d28:	f0 e0       	ldi	r31, 0x00	; 0
 d2a:	89 81       	ldd	r24, Y+1	; 0x01
 d2c:	80 83       	st	Z, r24
}
 d2e:	0f 90       	pop	r0
 d30:	cf 91       	pop	r28
 d32:	df 91       	pop	r29
 d34:	08 95       	ret

00000d36 <UART_U8ReadData>:
//	// apply circular buffer algorithm to read
//	u8 temp_readIdx = Read_buffer;
//}

u8 UART_U8ReadData(void)
{
 d36:	df 93       	push	r29
 d38:	cf 93       	push	r28
 d3a:	0f 92       	push	r0
 d3c:	cd b7       	in	r28, 0x3d	; 61
 d3e:	de b7       	in	r29, 0x3e	; 62
	u8 Local_U8Data = 0;
 d40:	19 82       	std	Y+1, r1	; 0x01
	if(GET_BIT(UCSRA, 7) == 1)
 d42:	eb e2       	ldi	r30, 0x2B	; 43
 d44:	f0 e0       	ldi	r31, 0x00	; 0
 d46:	80 81       	ld	r24, Z
 d48:	88 1f       	adc	r24, r24
 d4a:	88 27       	eor	r24, r24
 d4c:	88 1f       	adc	r24, r24
 d4e:	81 30       	cpi	r24, 0x01	; 1
 d50:	21 f4       	brne	.+8      	; 0xd5a <UART_U8ReadData+0x24>
	{
		Local_U8Data = UDR;
 d52:	ec e2       	ldi	r30, 0x2C	; 44
 d54:	f0 e0       	ldi	r31, 0x00	; 0
 d56:	80 81       	ld	r24, Z
 d58:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_U8Data;
 d5a:	89 81       	ldd	r24, Y+1	; 0x01
}
 d5c:	0f 90       	pop	r0
 d5e:	cf 91       	pop	r28
 d60:	df 91       	pop	r29
 d62:	08 95       	ret

00000d64 <UART_VidSendString>:

void UART_VidSendString(u8 * ptr_U8String)
{
 d64:	df 93       	push	r29
 d66:	cf 93       	push	r28
 d68:	00 d0       	rcall	.+0      	; 0xd6a <UART_VidSendString+0x6>
 d6a:	0f 92       	push	r0
 d6c:	cd b7       	in	r28, 0x3d	; 61
 d6e:	de b7       	in	r29, 0x3e	; 62
 d70:	9b 83       	std	Y+3, r25	; 0x03
 d72:	8a 83       	std	Y+2, r24	; 0x02
	u8 i=0;
 d74:	19 82       	std	Y+1, r1	; 0x01
 d76:	0e c0       	rjmp	.+28     	; 0xd94 <UART_VidSendString+0x30>
	while(ptr_U8String[i])
	{
		UART_VidSendData(ptr_U8String[i]);
 d78:	89 81       	ldd	r24, Y+1	; 0x01
 d7a:	28 2f       	mov	r18, r24
 d7c:	30 e0       	ldi	r19, 0x00	; 0
 d7e:	8a 81       	ldd	r24, Y+2	; 0x02
 d80:	9b 81       	ldd	r25, Y+3	; 0x03
 d82:	fc 01       	movw	r30, r24
 d84:	e2 0f       	add	r30, r18
 d86:	f3 1f       	adc	r31, r19
 d88:	80 81       	ld	r24, Z
 d8a:	0e 94 81 06 	call	0xd02	; 0xd02 <UART_VidSendData>
		i++;
 d8e:	89 81       	ldd	r24, Y+1	; 0x01
 d90:	8f 5f       	subi	r24, 0xFF	; 255
 d92:	89 83       	std	Y+1, r24	; 0x01
}

void UART_VidSendString(u8 * ptr_U8String)
{
	u8 i=0;
	while(ptr_U8String[i])
 d94:	89 81       	ldd	r24, Y+1	; 0x01
 d96:	28 2f       	mov	r18, r24
 d98:	30 e0       	ldi	r19, 0x00	; 0
 d9a:	8a 81       	ldd	r24, Y+2	; 0x02
 d9c:	9b 81       	ldd	r25, Y+3	; 0x03
 d9e:	fc 01       	movw	r30, r24
 da0:	e2 0f       	add	r30, r18
 da2:	f3 1f       	adc	r31, r19
 da4:	80 81       	ld	r24, Z
 da6:	88 23       	and	r24, r24
 da8:	39 f7       	brne	.-50     	; 0xd78 <UART_VidSendString+0x14>
	{
		UART_VidSendData(ptr_U8String[i]);
		i++;
	}
}
 daa:	0f 90       	pop	r0
 dac:	0f 90       	pop	r0
 dae:	0f 90       	pop	r0
 db0:	cf 91       	pop	r28
 db2:	df 91       	pop	r29
 db4:	08 95       	ret

00000db6 <__vector_13>:

// receive interrupt
u8 UART_Data;
u8 UART_ReadFlag;
void __vector_13(void)
{
 db6:	1f 92       	push	r1
 db8:	0f 92       	push	r0
 dba:	0f b6       	in	r0, 0x3f	; 63
 dbc:	0f 92       	push	r0
 dbe:	11 24       	eor	r1, r1
 dc0:	8f 93       	push	r24
 dc2:	ef 93       	push	r30
 dc4:	ff 93       	push	r31
 dc6:	df 93       	push	r29
 dc8:	cf 93       	push	r28
 dca:	cd b7       	in	r28, 0x3d	; 61
 dcc:	de b7       	in	r29, 0x3e	; 62
	UART_Data = UDR;
 dce:	ec e2       	ldi	r30, 0x2C	; 44
 dd0:	f0 e0       	ldi	r31, 0x00	; 0
 dd2:	80 81       	ld	r24, Z
 dd4:	80 93 6f 00 	sts	0x006F, r24
	UART_ReadFlag = 1;
 dd8:	81 e0       	ldi	r24, 0x01	; 1
 dda:	80 93 6e 00 	sts	0x006E, r24
}
 dde:	cf 91       	pop	r28
 de0:	df 91       	pop	r29
 de2:	ff 91       	pop	r31
 de4:	ef 91       	pop	r30
 de6:	8f 91       	pop	r24
 de8:	0f 90       	pop	r0
 dea:	0f be       	out	0x3f, r0	; 63
 dec:	0f 90       	pop	r0
 dee:	1f 90       	pop	r1
 df0:	18 95       	reti

00000df2 <main>:
#define SREG *((volatile u8 *) 0x5F)

extern u8 readBuffer[];

void main(void)
{
 df2:	df 93       	push	r29
 df4:	cf 93       	push	r28
 df6:	00 d0       	rcall	.+0      	; 0xdf8 <main+0x6>
 df8:	cd b7       	in	r28, 0x3d	; 61
 dfa:	de b7       	in	r29, 0x3e	; 62
	MCP2515_VidReceiveInit();
 dfc:	0e 94 2f 05 	call	0xa5e	; 0xa5e <MCP2515_VidReceiveInit>
	UART_VidInit();
 e00:	0e 94 45 06 	call	0xc8a	; 0xc8a <UART_VidInit>
	DIO_VidSetPinDirection(DIO_PORTD, DIO_PIN2, DIO_INPUT);
 e04:	83 e0       	ldi	r24, 0x03	; 3
 e06:	62 e0       	ldi	r22, 0x02	; 2
 e08:	40 e0       	ldi	r20, 0x00	; 0
 e0a:	0e 94 86 00 	call	0x10c	; 0x10c <DIO_VidSetPinDirection>
	u8 dataR = 0;
 e0e:	1a 82       	std	Y+2, r1	; 0x02

	while(1)
	{
		if(DIO_U8GetPinValue(DIO_PORTD, DIO_PIN2) == 0)
 e10:	83 e0       	ldi	r24, 0x03	; 3
 e12:	62 e0       	ldi	r22, 0x02	; 2
 e14:	0e 94 44 03 	call	0x688	; 0x688 <DIO_U8GetPinValue>
 e18:	88 23       	and	r24, r24
 e1a:	d1 f7       	brne	.-12     	; 0xe10 <main+0x1e>
		{
			MCP2515_VidReceiveCANmsg();
 e1c:	0e 94 65 05 	call	0xaca	; 0xaca <MCP2515_VidReceiveCANmsg>

			for(u8 i=0; i<8; i++)
 e20:	19 82       	std	Y+1, r1	; 0x01
 e22:	0f c0       	rjmp	.+30     	; 0xe42 <main+0x50>
			{
				dataR = readBuffer[6+i];
 e24:	89 81       	ldd	r24, Y+1	; 0x01
 e26:	88 2f       	mov	r24, r24
 e28:	90 e0       	ldi	r25, 0x00	; 0
 e2a:	06 96       	adiw	r24, 0x06	; 6
 e2c:	fc 01       	movw	r30, r24
 e2e:	e0 5a       	subi	r30, 0xA0	; 160
 e30:	ff 4f       	sbci	r31, 0xFF	; 255
 e32:	80 81       	ld	r24, Z
 e34:	8a 83       	std	Y+2, r24	; 0x02
				UART_VidSendData(dataR);
 e36:	8a 81       	ldd	r24, Y+2	; 0x02
 e38:	0e 94 81 06 	call	0xd02	; 0xd02 <UART_VidSendData>
	{
		if(DIO_U8GetPinValue(DIO_PORTD, DIO_PIN2) == 0)
		{
			MCP2515_VidReceiveCANmsg();

			for(u8 i=0; i<8; i++)
 e3c:	89 81       	ldd	r24, Y+1	; 0x01
 e3e:	8f 5f       	subi	r24, 0xFF	; 255
 e40:	89 83       	std	Y+1, r24	; 0x01
 e42:	89 81       	ldd	r24, Y+1	; 0x01
 e44:	88 30       	cpi	r24, 0x08	; 8
 e46:	70 f3       	brcs	.-36     	; 0xe24 <main+0x32>
			{
				dataR = readBuffer[6+i];
				UART_VidSendData(dataR);
			}
			UART_VidSendData('\r');
 e48:	8d e0       	ldi	r24, 0x0D	; 13
 e4a:	0e 94 81 06 	call	0xd02	; 0xd02 <UART_VidSendData>
			UART_VidSendData('\n');
 e4e:	8a e0       	ldi	r24, 0x0A	; 10
 e50:	0e 94 81 06 	call	0xd02	; 0xd02 <UART_VidSendData>
 e54:	dd cf       	rjmp	.-70     	; 0xe10 <main+0x1e>

00000e56 <_exit>:
 e56:	f8 94       	cli

00000e58 <__stop_program>:
 e58:	ff cf       	rjmp	.-2      	; 0xe58 <__stop_program>
